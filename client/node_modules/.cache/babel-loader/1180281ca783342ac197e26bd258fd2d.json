{"ast":null,"code":"\"use strict\";\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.CallCredentials = void 0;\n\nconst metadata_1 = require(\"./metadata\");\n\nfunction isCurrentOauth2Client(client) {\n  return 'getRequestHeaders' in client && typeof client.getRequestHeaders === 'function';\n}\n/**\n * A class that represents a generic method of adding authentication-related\n * metadata on a per-request basis.\n */\n\n\nclass CallCredentials {\n  /**\n   * Creates a new CallCredentials object from a given function that generates\n   * Metadata objects.\n   * @param metadataGenerator A function that accepts a set of options, and\n   * generates a Metadata object based on these options, which is passed back\n   * to the caller via a supplied (err, metadata) callback.\n   */\n  static createFromMetadataGenerator(metadataGenerator) {\n    return new SingleCallCredentials(metadataGenerator);\n  }\n  /**\n   * Create a gRPC credential from a Google credential object.\n   * @param googleCredentials The authentication client to use.\n   * @return The resulting CallCredentials object.\n   */\n\n\n  static createFromGoogleCredential(googleCredentials) {\n    return CallCredentials.createFromMetadataGenerator((options, callback) => {\n      let getHeaders;\n\n      if (isCurrentOauth2Client(googleCredentials)) {\n        getHeaders = googleCredentials.getRequestHeaders(options.service_url);\n      } else {\n        getHeaders = new Promise((resolve, reject) => {\n          googleCredentials.getRequestMetadata(options.service_url, (err, headers) => {\n            if (err) {\n              reject(err);\n              return;\n            }\n\n            resolve(headers);\n          });\n        });\n      }\n\n      getHeaders.then(headers => {\n        const metadata = new metadata_1.Metadata();\n\n        for (const key of Object.keys(headers)) {\n          metadata.add(key, headers[key]);\n        }\n\n        callback(null, metadata);\n      }, err => {\n        callback(err);\n      });\n    });\n  }\n\n  static createEmpty() {\n    return new EmptyCallCredentials();\n  }\n\n}\n\nexports.CallCredentials = CallCredentials;\n\nclass ComposedCallCredentials extends CallCredentials {\n  constructor(creds) {\n    super();\n    this.creds = creds;\n  }\n\n  async generateMetadata(options) {\n    const base = new metadata_1.Metadata();\n    const generated = await Promise.all(this.creds.map(cred => cred.generateMetadata(options)));\n\n    for (const gen of generated) {\n      base.merge(gen);\n    }\n\n    return base;\n  }\n\n  compose(other) {\n    return new ComposedCallCredentials(this.creds.concat([other]));\n  }\n\n  _equals(other) {\n    if (this === other) {\n      return true;\n    }\n\n    if (other instanceof ComposedCallCredentials) {\n      return this.creds.every((value, index) => value._equals(other.creds[index]));\n    } else {\n      return false;\n    }\n  }\n\n}\n\nclass SingleCallCredentials extends CallCredentials {\n  constructor(metadataGenerator) {\n    super();\n    this.metadataGenerator = metadataGenerator;\n  }\n\n  generateMetadata(options) {\n    return new Promise((resolve, reject) => {\n      this.metadataGenerator(options, (err, metadata) => {\n        if (metadata !== undefined) {\n          resolve(metadata);\n        } else {\n          reject(err);\n        }\n      });\n    });\n  }\n\n  compose(other) {\n    return new ComposedCallCredentials([this, other]);\n  }\n\n  _equals(other) {\n    if (this === other) {\n      return true;\n    }\n\n    if (other instanceof SingleCallCredentials) {\n      return this.metadataGenerator === other.metadataGenerator;\n    } else {\n      return false;\n    }\n  }\n\n}\n\nclass EmptyCallCredentials extends CallCredentials {\n  generateMetadata(options) {\n    return Promise.resolve(new metadata_1.Metadata());\n  }\n\n  compose(other) {\n    return other;\n  }\n\n  _equals(other) {\n    return other instanceof EmptyCallCredentials;\n  }\n\n}","map":{"version":3,"sources":["../../src/call-credentials.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.CallCredentials = void 0;\nconst metadata_1 = require(\"./metadata\");\nfunction isCurrentOauth2Client(client) {\n    return ('getRequestHeaders' in client &&\n        typeof client.getRequestHeaders === 'function');\n}\n/**\n * A class that represents a generic method of adding authentication-related\n * metadata on a per-request basis.\n */\nclass CallCredentials {\n    /**\n     * Creates a new CallCredentials object from a given function that generates\n     * Metadata objects.\n     * @param metadataGenerator A function that accepts a set of options, and\n     * generates a Metadata object based on these options, which is passed back\n     * to the caller via a supplied (err, metadata) callback.\n     */\n    static createFromMetadataGenerator(metadataGenerator) {\n        return new SingleCallCredentials(metadataGenerator);\n    }\n    /**\n     * Create a gRPC credential from a Google credential object.\n     * @param googleCredentials The authentication client to use.\n     * @return The resulting CallCredentials object.\n     */\n    static createFromGoogleCredential(googleCredentials) {\n        return CallCredentials.createFromMetadataGenerator((options, callback) => {\n            let getHeaders;\n            if (isCurrentOauth2Client(googleCredentials)) {\n                getHeaders = googleCredentials.getRequestHeaders(options.service_url);\n            }\n            else {\n                getHeaders = new Promise((resolve, reject) => {\n                    googleCredentials.getRequestMetadata(options.service_url, (err, headers) => {\n                        if (err) {\n                            reject(err);\n                            return;\n                        }\n                        resolve(headers);\n                    });\n                });\n            }\n            getHeaders.then((headers) => {\n                const metadata = new metadata_1.Metadata();\n                for (const key of Object.keys(headers)) {\n                    metadata.add(key, headers[key]);\n                }\n                callback(null, metadata);\n            }, (err) => {\n                callback(err);\n            });\n        });\n    }\n    static createEmpty() {\n        return new EmptyCallCredentials();\n    }\n}\nexports.CallCredentials = CallCredentials;\nclass ComposedCallCredentials extends CallCredentials {\n    constructor(creds) {\n        super();\n        this.creds = creds;\n    }\n    async generateMetadata(options) {\n        const base = new metadata_1.Metadata();\n        const generated = await Promise.all(this.creds.map((cred) => cred.generateMetadata(options)));\n        for (const gen of generated) {\n            base.merge(gen);\n        }\n        return base;\n    }\n    compose(other) {\n        return new ComposedCallCredentials(this.creds.concat([other]));\n    }\n    _equals(other) {\n        if (this === other) {\n            return true;\n        }\n        if (other instanceof ComposedCallCredentials) {\n            return this.creds.every((value, index) => value._equals(other.creds[index]));\n        }\n        else {\n            return false;\n        }\n    }\n}\nclass SingleCallCredentials extends CallCredentials {\n    constructor(metadataGenerator) {\n        super();\n        this.metadataGenerator = metadataGenerator;\n    }\n    generateMetadata(options) {\n        return new Promise((resolve, reject) => {\n            this.metadataGenerator(options, (err, metadata) => {\n                if (metadata !== undefined) {\n                    resolve(metadata);\n                }\n                else {\n                    reject(err);\n                }\n            });\n        });\n    }\n    compose(other) {\n        return new ComposedCallCredentials([this, other]);\n    }\n    _equals(other) {\n        if (this === other) {\n            return true;\n        }\n        if (other instanceof SingleCallCredentials) {\n            return this.metadataGenerator === other.metadataGenerator;\n        }\n        else {\n            return false;\n        }\n    }\n}\nclass EmptyCallCredentials extends CallCredentials {\n    generateMetadata(options) {\n        return Promise.resolve(new metadata_1.Metadata());\n    }\n    compose(other) {\n        return other;\n    }\n    _equals(other) {\n        return other instanceof EmptyCallCredentials;\n    }\n}\n//# sourceMappingURL=call-credentials.js.map"]},"metadata":{},"sourceType":"script"}