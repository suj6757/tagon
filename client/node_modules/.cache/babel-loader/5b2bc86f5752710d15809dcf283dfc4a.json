{"ast":null,"code":"\"use strict\";\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ChannelImplementation = exports.ConnectivityState = void 0;\n\nconst call_stream_1 = require(\"./call-stream\");\n\nconst channel_credentials_1 = require(\"./channel-credentials\");\n\nconst resolving_load_balancer_1 = require(\"./resolving-load-balancer\");\n\nconst subchannel_pool_1 = require(\"./subchannel-pool\");\n\nconst picker_1 = require(\"./picker\");\n\nconst constants_1 = require(\"./constants\");\n\nconst filter_stack_1 = require(\"./filter-stack\");\n\nconst call_credentials_filter_1 = require(\"./call-credentials-filter\");\n\nconst deadline_filter_1 = require(\"./deadline-filter\");\n\nconst compression_filter_1 = require(\"./compression-filter\");\n\nconst resolver_1 = require(\"./resolver\");\n\nconst logging_1 = require(\"./logging\");\n\nconst max_message_size_filter_1 = require(\"./max-message-size-filter\");\n\nconst http_proxy_1 = require(\"./http_proxy\");\n\nconst uri_parser_1 = require(\"./uri-parser\");\n\nvar ConnectivityState;\n\n(function (ConnectivityState) {\n  ConnectivityState[ConnectivityState[\"IDLE\"] = 0] = \"IDLE\";\n  ConnectivityState[ConnectivityState[\"CONNECTING\"] = 1] = \"CONNECTING\";\n  ConnectivityState[ConnectivityState[\"READY\"] = 2] = \"READY\";\n  ConnectivityState[ConnectivityState[\"TRANSIENT_FAILURE\"] = 3] = \"TRANSIENT_FAILURE\";\n  ConnectivityState[ConnectivityState[\"SHUTDOWN\"] = 4] = \"SHUTDOWN\";\n})(ConnectivityState = exports.ConnectivityState || (exports.ConnectivityState = {}));\n/**\n * See https://nodejs.org/api/timers.html#timers_setinterval_callback_delay_args\n */\n\n\nconst MAX_TIMEOUT_TIME = 2147483647;\nlet nextCallNumber = 0;\n\nfunction getNewCallNumber() {\n  const callNumber = nextCallNumber;\n  nextCallNumber += 1;\n\n  if (nextCallNumber >= Number.MAX_SAFE_INTEGER) {\n    nextCallNumber = 0;\n  }\n\n  return callNumber;\n}\n\nclass ChannelImplementation {\n  constructor(target, credentials, options) {\n    var _a, _b, _c;\n\n    this.credentials = credentials;\n    this.options = options;\n    this.connectivityState = ConnectivityState.IDLE;\n    this.currentPicker = new picker_1.UnavailablePicker();\n    /**\n     * Calls queued up to get a call config. Should only be populated before the\n     * first time the resolver returns a result, which includes the ConfigSelector.\n     */\n\n    this.configSelectionQueue = [];\n    this.pickQueue = [];\n    this.connectivityStateWatchers = [];\n    this.configSelector = null;\n\n    if (typeof target !== 'string') {\n      throw new TypeError('Channel target must be a string');\n    }\n\n    if (!(credentials instanceof channel_credentials_1.ChannelCredentials)) {\n      throw new TypeError('Channel credentials must be a ChannelCredentials object');\n    }\n\n    if (options) {\n      if (typeof options !== 'object' || !Object.values(options).every(value => typeof value === 'string' || typeof value === 'number' || typeof value === 'undefined')) {\n        throw new TypeError('Channel options must be an object with string or number values');\n      }\n    }\n\n    const originalTargetUri = uri_parser_1.parseUri(target);\n\n    if (originalTargetUri === null) {\n      throw new Error(`Could not parse target name \"${target}\"`);\n    }\n    /* This ensures that the target has a scheme that is registered with the\n     * resolver */\n\n\n    const defaultSchemeMapResult = resolver_1.mapUriDefaultScheme(originalTargetUri);\n\n    if (defaultSchemeMapResult === null) {\n      throw new Error(`Could not find a default scheme for target name \"${target}\"`);\n    }\n\n    this.callRefTimer = setInterval(() => {}, MAX_TIMEOUT_TIME);\n    (_b = (_a = this.callRefTimer).unref) === null || _b === void 0 ? void 0 : _b.call(_a);\n\n    if (this.options['grpc.default_authority']) {\n      this.defaultAuthority = this.options['grpc.default_authority'];\n    } else {\n      this.defaultAuthority = resolver_1.getDefaultAuthority(defaultSchemeMapResult);\n    }\n\n    const proxyMapResult = http_proxy_1.mapProxyName(defaultSchemeMapResult, options);\n    this.target = proxyMapResult.target;\n    this.options = Object.assign({}, this.options, proxyMapResult.extraOptions);\n    /* The global boolean parameter to getSubchannelPool has the inverse meaning to what\n     * the grpc.use_local_subchannel_pool channel option means. */\n\n    this.subchannelPool = subchannel_pool_1.getSubchannelPool(((_c = options['grpc.use_local_subchannel_pool']) !== null && _c !== void 0 ? _c : 0) === 0);\n    const channelControlHelper = {\n      createSubchannel: (subchannelAddress, subchannelArgs) => {\n        return this.subchannelPool.getOrCreateSubchannel(this.target, subchannelAddress, Object.assign({}, this.options, subchannelArgs), this.credentials);\n      },\n      updateState: (connectivityState, picker) => {\n        this.currentPicker = picker;\n        const queueCopy = this.pickQueue.slice();\n        this.pickQueue = [];\n        this.callRefTimerUnref();\n\n        for (const {\n          callStream,\n          callMetadata,\n          callConfig\n        } of queueCopy) {\n          this.tryPick(callStream, callMetadata, callConfig);\n        }\n\n        this.updateState(connectivityState);\n      },\n      requestReresolution: () => {\n        // This should never be called.\n        throw new Error('Resolving load balancer should never call requestReresolution');\n      }\n    };\n    this.resolvingLoadBalancer = new resolving_load_balancer_1.ResolvingLoadBalancer(this.target, channelControlHelper, options, configSelector => {\n      this.configSelector = configSelector;\n      /* We process the queue asynchronously to ensure that the corresponding\n       * load balancer update has completed. */\n\n      process.nextTick(() => {\n        const localQueue = this.configSelectionQueue;\n        this.configSelectionQueue = [];\n        this.callRefTimerUnref();\n\n        for (const {\n          callStream,\n          callMetadata\n        } of localQueue) {\n          this.tryGetConfig(callStream, callMetadata);\n        }\n\n        this.configSelectionQueue = [];\n      });\n    }, status => {\n      if (this.configSelectionQueue.length > 0) {\n        logging_1.trace(constants_1.LogVerbosity.DEBUG, 'channel', 'Name resolution failed for target ' + uri_parser_1.uriToString(this.target) + ' with calls queued for config selection');\n      }\n\n      const localQueue = this.configSelectionQueue;\n      this.configSelectionQueue = [];\n      this.callRefTimerUnref();\n\n      for (const {\n        callStream,\n        callMetadata\n      } of localQueue) {\n        if (callMetadata.getOptions().waitForReady) {\n          this.callRefTimerRef();\n          this.configSelectionQueue.push({\n            callStream,\n            callMetadata\n          });\n        } else {\n          callStream.cancelWithStatus(status.code, status.details);\n        }\n      }\n    });\n    this.filterStackFactory = new filter_stack_1.FilterStackFactory([new call_credentials_filter_1.CallCredentialsFilterFactory(this), new deadline_filter_1.DeadlineFilterFactory(this), new max_message_size_filter_1.MaxMessageSizeFilterFactory(this.options), new compression_filter_1.CompressionFilterFactory(this)]);\n  }\n\n  callRefTimerRef() {\n    var _a, _b, _c, _d; // If the hasRef function does not exist, always run the code\n\n\n    if (!((_b = (_a = this.callRefTimer).hasRef) === null || _b === void 0 ? void 0 : _b.call(_a))) {\n      logging_1.trace(constants_1.LogVerbosity.DEBUG, 'channel', 'callRefTimer.ref | configSelectionQueue.length=' + this.configSelectionQueue.length + ' pickQueue.length=' + this.pickQueue.length);\n      (_d = (_c = this.callRefTimer).ref) === null || _d === void 0 ? void 0 : _d.call(_c);\n    }\n  }\n\n  callRefTimerUnref() {\n    var _a, _b; // If the hasRef function does not exist, always run the code\n\n\n    if (!this.callRefTimer.hasRef || this.callRefTimer.hasRef()) {\n      logging_1.trace(constants_1.LogVerbosity.DEBUG, 'channel', 'callRefTimer.unref | configSelectionQueue.length=' + this.configSelectionQueue.length + ' pickQueue.length=' + this.pickQueue.length);\n      (_b = (_a = this.callRefTimer).unref) === null || _b === void 0 ? void 0 : _b.call(_a);\n    }\n  }\n\n  pushPick(callStream, callMetadata, callConfig) {\n    this.pickQueue.push({\n      callStream,\n      callMetadata,\n      callConfig\n    });\n    this.callRefTimerRef();\n  }\n  /**\n   * Check the picker output for the given call and corresponding metadata,\n   * and take any relevant actions. Should not be called while iterating\n   * over pickQueue.\n   * @param callStream\n   * @param callMetadata\n   */\n\n\n  tryPick(callStream, callMetadata, callConfig) {\n    var _a, _b, _c;\n\n    const pickResult = this.currentPicker.pick({\n      metadata: callMetadata,\n      extraPickInfo: callConfig.pickInformation\n    });\n    logging_1.trace(constants_1.LogVerbosity.DEBUG, 'channel', 'Pick result: ' + picker_1.PickResultType[pickResult.pickResultType] + ' subchannel: ' + ((_a = pickResult.subchannel) === null || _a === void 0 ? void 0 : _a.getAddress()) + ' status: ' + ((_b = pickResult.status) === null || _b === void 0 ? void 0 : _b.code) + ' ' + ((_c = pickResult.status) === null || _c === void 0 ? void 0 : _c.details));\n\n    switch (pickResult.pickResultType) {\n      case picker_1.PickResultType.COMPLETE:\n        if (pickResult.subchannel === null) {\n          callStream.cancelWithStatus(constants_1.Status.UNAVAILABLE, 'Request dropped by load balancing policy'); // End the call with an error\n        } else {\n          /* If the subchannel is not in the READY state, that indicates a bug\n           * somewhere in the load balancer or picker. So, we log an error and\n           * queue the pick to be tried again later. */\n          if (pickResult.subchannel.getConnectivityState() !== ConnectivityState.READY) {\n            logging_1.log(constants_1.LogVerbosity.ERROR, 'Error: COMPLETE pick result subchannel ' + pickResult.subchannel.getAddress() + ' has state ' + ConnectivityState[pickResult.subchannel.getConnectivityState()]);\n            this.pushPick(callStream, callMetadata, callConfig);\n            break;\n          }\n          /* We need to clone the callMetadata here because the transparent\n           * retry code in the promise resolution handler use the same\n           * callMetadata object, so it needs to stay unmodified */\n\n\n          callStream.filterStack.sendMetadata(Promise.resolve(callMetadata.clone())).then(finalMetadata => {\n            var _a, _b, _c;\n\n            const subchannelState = pickResult.subchannel.getConnectivityState();\n\n            if (subchannelState === ConnectivityState.READY) {\n              try {\n                pickResult.subchannel.startCallStream(finalMetadata, callStream, (_a = pickResult.extraFilterFactory) !== null && _a !== void 0 ? _a : undefined);\n                /* If we reach this point, the call stream has started\n                 * successfully */\n\n                (_b = callConfig.onCommitted) === null || _b === void 0 ? void 0 : _b.call(callConfig);\n                (_c = pickResult.onCallStarted) === null || _c === void 0 ? void 0 : _c.call(pickResult);\n              } catch (error) {\n                if (error.code === 'ERR_HTTP2_GOAWAY_SESSION') {\n                  /* An error here indicates that something went wrong with\n                   * the picked subchannel's http2 stream right before we\n                   * tried to start the stream. We are handling a promise\n                   * result here, so this is asynchronous with respect to the\n                   * original tryPick call, so calling it again is not\n                   * recursive. We call tryPick immediately instead of\n                   * queueing this pick again because handling the queue is\n                   * triggered by state changes, and we want to immediately\n                   * check if the state has already changed since the\n                   * previous tryPick call. We do this instead of cancelling\n                   * the stream because the correct behavior may be\n                   * re-queueing instead, based on the logic in the rest of\n                   * tryPick */\n                  logging_1.trace(constants_1.LogVerbosity.INFO, 'channel', 'Failed to start call on picked subchannel ' + pickResult.subchannel.getAddress() + ' with error ' + error.message + '. Retrying pick');\n                  this.tryPick(callStream, callMetadata, callConfig);\n                } else {\n                  logging_1.trace(constants_1.LogVerbosity.INFO, 'channel', 'Failed to start call on picked subchanel ' + pickResult.subchannel.getAddress() + ' with error ' + error.message + '. Ending call');\n                  callStream.cancelWithStatus(constants_1.Status.INTERNAL, `Failed to start HTTP/2 stream with error: ${error.message}`);\n                }\n              }\n            } else {\n              /* The logic for doing this here is the same as in the catch\n               * block above */\n              logging_1.trace(constants_1.LogVerbosity.INFO, 'channel', 'Picked subchannel ' + pickResult.subchannel.getAddress() + ' has state ' + ConnectivityState[subchannelState] + ' after metadata filters. Retrying pick');\n              this.tryPick(callStream, callMetadata, callConfig);\n            }\n          }, error => {\n            // We assume the error code isn't 0 (Status.OK)\n            callStream.cancelWithStatus(typeof error.code === 'number' ? error.code : constants_1.Status.UNKNOWN, `Getting metadata from plugin failed with error: ${error.message}`);\n          });\n        }\n\n        break;\n\n      case picker_1.PickResultType.QUEUE:\n        this.pushPick(callStream, callMetadata, callConfig);\n        break;\n\n      case picker_1.PickResultType.TRANSIENT_FAILURE:\n        if (callMetadata.getOptions().waitForReady) {\n          this.pushPick(callStream, callMetadata, callConfig);\n        } else {\n          callStream.cancelWithStatus(pickResult.status.code, pickResult.status.details);\n        }\n\n        break;\n\n      case picker_1.PickResultType.DROP:\n        callStream.cancelWithStatus(pickResult.status.code, pickResult.status.details);\n        break;\n\n      default:\n        throw new Error(`Invalid state: unknown pickResultType ${pickResult.pickResultType}`);\n    }\n  }\n\n  removeConnectivityStateWatcher(watcherObject) {\n    const watcherIndex = this.connectivityStateWatchers.findIndex(value => value === watcherObject);\n\n    if (watcherIndex >= 0) {\n      this.connectivityStateWatchers.splice(watcherIndex, 1);\n    }\n  }\n\n  updateState(newState) {\n    logging_1.trace(constants_1.LogVerbosity.DEBUG, 'connectivity_state', uri_parser_1.uriToString(this.target) + ' ' + ConnectivityState[this.connectivityState] + ' -> ' + ConnectivityState[newState]);\n    this.connectivityState = newState;\n    const watchersCopy = this.connectivityStateWatchers.slice();\n\n    for (const watcherObject of watchersCopy) {\n      if (newState !== watcherObject.currentState) {\n        if (watcherObject.timer) {\n          clearTimeout(watcherObject.timer);\n        }\n\n        this.removeConnectivityStateWatcher(watcherObject);\n        watcherObject.callback();\n      }\n    }\n  }\n\n  tryGetConfig(stream, metadata) {\n    if (this.configSelector === null) {\n      /* This branch will only be taken at the beginning of the channel's life,\n       * before the resolver ever returns a result. So, the\n       * ResolvingLoadBalancer may be idle and if so it needs to be kicked\n       * because it now has a pending request. */\n      this.resolvingLoadBalancer.exitIdle();\n      this.configSelectionQueue.push({\n        callStream: stream,\n        callMetadata: metadata\n      });\n      this.callRefTimerRef();\n    } else {\n      const callConfig = this.configSelector(stream.getMethod(), metadata);\n\n      if (callConfig.status === constants_1.Status.OK) {\n        this.tryPick(stream, metadata, callConfig);\n      } else {\n        stream.cancelWithStatus(callConfig.status, \"Failed to route call to method \" + stream.getMethod());\n      }\n    }\n  }\n\n  _startCallStream(stream, metadata) {\n    this.tryGetConfig(stream, metadata.clone());\n  }\n\n  close() {\n    this.resolvingLoadBalancer.destroy();\n    this.updateState(ConnectivityState.SHUTDOWN);\n    clearInterval(this.callRefTimer);\n    this.subchannelPool.unrefUnusedSubchannels();\n  }\n\n  getTarget() {\n    return uri_parser_1.uriToString(this.target);\n  }\n\n  getConnectivityState(tryToConnect) {\n    const connectivityState = this.connectivityState;\n\n    if (tryToConnect) {\n      this.resolvingLoadBalancer.exitIdle();\n    }\n\n    return connectivityState;\n  }\n\n  watchConnectivityState(currentState, deadline, callback) {\n    if (this.connectivityState === ConnectivityState.SHUTDOWN) {\n      throw new Error('Channel has been shut down');\n    }\n\n    let timer = null;\n\n    if (deadline !== Infinity) {\n      const deadlineDate = deadline instanceof Date ? deadline : new Date(deadline);\n      const now = new Date();\n\n      if (deadline === -Infinity || deadlineDate <= now) {\n        process.nextTick(callback, new Error('Deadline passed without connectivity state change'));\n        return;\n      }\n\n      timer = setTimeout(() => {\n        this.removeConnectivityStateWatcher(watcherObject);\n        callback(new Error('Deadline passed without connectivity state change'));\n      }, deadlineDate.getTime() - now.getTime());\n    }\n\n    const watcherObject = {\n      currentState,\n      callback,\n      timer\n    };\n    this.connectivityStateWatchers.push(watcherObject);\n  }\n\n  createCall(method, deadline, host, parentCall, propagateFlags) {\n    if (typeof method !== 'string') {\n      throw new TypeError('Channel#createCall: method must be a string');\n    }\n\n    if (!(typeof deadline === 'number' || deadline instanceof Date)) {\n      throw new TypeError('Channel#createCall: deadline must be a number or Date');\n    }\n\n    if (this.connectivityState === ConnectivityState.SHUTDOWN) {\n      throw new Error('Channel has been shut down');\n    }\n\n    const callNumber = getNewCallNumber();\n    logging_1.trace(constants_1.LogVerbosity.DEBUG, 'channel', uri_parser_1.uriToString(this.target) + ' createCall [' + callNumber + '] method=\"' + method + '\", deadline=' + deadline);\n    const finalOptions = {\n      deadline: deadline,\n      flags: propagateFlags !== null && propagateFlags !== void 0 ? propagateFlags : constants_1.Propagate.DEFAULTS,\n      host: host !== null && host !== void 0 ? host : this.defaultAuthority,\n      parentCall: parentCall\n    };\n    const stream = new call_stream_1.Http2CallStream(method, this, finalOptions, this.filterStackFactory, this.credentials._getCallCredentials(), callNumber);\n    return stream;\n  }\n\n}\n\nexports.ChannelImplementation = ChannelImplementation;","map":{"version":3,"sources":["../../src/channel.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ChannelImplementation = exports.ConnectivityState = void 0;\nconst call_stream_1 = require(\"./call-stream\");\nconst channel_credentials_1 = require(\"./channel-credentials\");\nconst resolving_load_balancer_1 = require(\"./resolving-load-balancer\");\nconst subchannel_pool_1 = require(\"./subchannel-pool\");\nconst picker_1 = require(\"./picker\");\nconst constants_1 = require(\"./constants\");\nconst filter_stack_1 = require(\"./filter-stack\");\nconst call_credentials_filter_1 = require(\"./call-credentials-filter\");\nconst deadline_filter_1 = require(\"./deadline-filter\");\nconst compression_filter_1 = require(\"./compression-filter\");\nconst resolver_1 = require(\"./resolver\");\nconst logging_1 = require(\"./logging\");\nconst max_message_size_filter_1 = require(\"./max-message-size-filter\");\nconst http_proxy_1 = require(\"./http_proxy\");\nconst uri_parser_1 = require(\"./uri-parser\");\nvar ConnectivityState;\n(function (ConnectivityState) {\n    ConnectivityState[ConnectivityState[\"IDLE\"] = 0] = \"IDLE\";\n    ConnectivityState[ConnectivityState[\"CONNECTING\"] = 1] = \"CONNECTING\";\n    ConnectivityState[ConnectivityState[\"READY\"] = 2] = \"READY\";\n    ConnectivityState[ConnectivityState[\"TRANSIENT_FAILURE\"] = 3] = \"TRANSIENT_FAILURE\";\n    ConnectivityState[ConnectivityState[\"SHUTDOWN\"] = 4] = \"SHUTDOWN\";\n})(ConnectivityState = exports.ConnectivityState || (exports.ConnectivityState = {}));\n/**\n * See https://nodejs.org/api/timers.html#timers_setinterval_callback_delay_args\n */\nconst MAX_TIMEOUT_TIME = 2147483647;\nlet nextCallNumber = 0;\nfunction getNewCallNumber() {\n    const callNumber = nextCallNumber;\n    nextCallNumber += 1;\n    if (nextCallNumber >= Number.MAX_SAFE_INTEGER) {\n        nextCallNumber = 0;\n    }\n    return callNumber;\n}\nclass ChannelImplementation {\n    constructor(target, credentials, options) {\n        var _a, _b, _c;\n        this.credentials = credentials;\n        this.options = options;\n        this.connectivityState = ConnectivityState.IDLE;\n        this.currentPicker = new picker_1.UnavailablePicker();\n        /**\n         * Calls queued up to get a call config. Should only be populated before the\n         * first time the resolver returns a result, which includes the ConfigSelector.\n         */\n        this.configSelectionQueue = [];\n        this.pickQueue = [];\n        this.connectivityStateWatchers = [];\n        this.configSelector = null;\n        if (typeof target !== 'string') {\n            throw new TypeError('Channel target must be a string');\n        }\n        if (!(credentials instanceof channel_credentials_1.ChannelCredentials)) {\n            throw new TypeError('Channel credentials must be a ChannelCredentials object');\n        }\n        if (options) {\n            if (typeof options !== 'object' ||\n                !Object.values(options).every((value) => typeof value === 'string' ||\n                    typeof value === 'number' ||\n                    typeof value === 'undefined')) {\n                throw new TypeError('Channel options must be an object with string or number values');\n            }\n        }\n        const originalTargetUri = uri_parser_1.parseUri(target);\n        if (originalTargetUri === null) {\n            throw new Error(`Could not parse target name \"${target}\"`);\n        }\n        /* This ensures that the target has a scheme that is registered with the\n         * resolver */\n        const defaultSchemeMapResult = resolver_1.mapUriDefaultScheme(originalTargetUri);\n        if (defaultSchemeMapResult === null) {\n            throw new Error(`Could not find a default scheme for target name \"${target}\"`);\n        }\n        this.callRefTimer = setInterval(() => { }, MAX_TIMEOUT_TIME);\n        (_b = (_a = this.callRefTimer).unref) === null || _b === void 0 ? void 0 : _b.call(_a);\n        if (this.options['grpc.default_authority']) {\n            this.defaultAuthority = this.options['grpc.default_authority'];\n        }\n        else {\n            this.defaultAuthority = resolver_1.getDefaultAuthority(defaultSchemeMapResult);\n        }\n        const proxyMapResult = http_proxy_1.mapProxyName(defaultSchemeMapResult, options);\n        this.target = proxyMapResult.target;\n        this.options = Object.assign({}, this.options, proxyMapResult.extraOptions);\n        /* The global boolean parameter to getSubchannelPool has the inverse meaning to what\n         * the grpc.use_local_subchannel_pool channel option means. */\n        this.subchannelPool = subchannel_pool_1.getSubchannelPool(((_c = options['grpc.use_local_subchannel_pool']) !== null && _c !== void 0 ? _c : 0) === 0);\n        const channelControlHelper = {\n            createSubchannel: (subchannelAddress, subchannelArgs) => {\n                return this.subchannelPool.getOrCreateSubchannel(this.target, subchannelAddress, Object.assign({}, this.options, subchannelArgs), this.credentials);\n            },\n            updateState: (connectivityState, picker) => {\n                this.currentPicker = picker;\n                const queueCopy = this.pickQueue.slice();\n                this.pickQueue = [];\n                this.callRefTimerUnref();\n                for (const { callStream, callMetadata, callConfig } of queueCopy) {\n                    this.tryPick(callStream, callMetadata, callConfig);\n                }\n                this.updateState(connectivityState);\n            },\n            requestReresolution: () => {\n                // This should never be called.\n                throw new Error('Resolving load balancer should never call requestReresolution');\n            },\n        };\n        this.resolvingLoadBalancer = new resolving_load_balancer_1.ResolvingLoadBalancer(this.target, channelControlHelper, options, (configSelector) => {\n            this.configSelector = configSelector;\n            /* We process the queue asynchronously to ensure that the corresponding\n             * load balancer update has completed. */\n            process.nextTick(() => {\n                const localQueue = this.configSelectionQueue;\n                this.configSelectionQueue = [];\n                this.callRefTimerUnref();\n                for (const { callStream, callMetadata } of localQueue) {\n                    this.tryGetConfig(callStream, callMetadata);\n                }\n                this.configSelectionQueue = [];\n            });\n        }, (status) => {\n            if (this.configSelectionQueue.length > 0) {\n                logging_1.trace(constants_1.LogVerbosity.DEBUG, 'channel', 'Name resolution failed for target ' + uri_parser_1.uriToString(this.target) + ' with calls queued for config selection');\n            }\n            const localQueue = this.configSelectionQueue;\n            this.configSelectionQueue = [];\n            this.callRefTimerUnref();\n            for (const { callStream, callMetadata } of localQueue) {\n                if (callMetadata.getOptions().waitForReady) {\n                    this.callRefTimerRef();\n                    this.configSelectionQueue.push({ callStream, callMetadata });\n                }\n                else {\n                    callStream.cancelWithStatus(status.code, status.details);\n                }\n            }\n        });\n        this.filterStackFactory = new filter_stack_1.FilterStackFactory([\n            new call_credentials_filter_1.CallCredentialsFilterFactory(this),\n            new deadline_filter_1.DeadlineFilterFactory(this),\n            new max_message_size_filter_1.MaxMessageSizeFilterFactory(this.options),\n            new compression_filter_1.CompressionFilterFactory(this),\n        ]);\n    }\n    callRefTimerRef() {\n        var _a, _b, _c, _d;\n        // If the hasRef function does not exist, always run the code\n        if (!((_b = (_a = this.callRefTimer).hasRef) === null || _b === void 0 ? void 0 : _b.call(_a))) {\n            logging_1.trace(constants_1.LogVerbosity.DEBUG, 'channel', 'callRefTimer.ref | configSelectionQueue.length=' + this.configSelectionQueue.length + ' pickQueue.length=' + this.pickQueue.length);\n            (_d = (_c = this.callRefTimer).ref) === null || _d === void 0 ? void 0 : _d.call(_c);\n        }\n    }\n    callRefTimerUnref() {\n        var _a, _b;\n        // If the hasRef function does not exist, always run the code\n        if ((!this.callRefTimer.hasRef) || (this.callRefTimer.hasRef())) {\n            logging_1.trace(constants_1.LogVerbosity.DEBUG, 'channel', 'callRefTimer.unref | configSelectionQueue.length=' + this.configSelectionQueue.length + ' pickQueue.length=' + this.pickQueue.length);\n            (_b = (_a = this.callRefTimer).unref) === null || _b === void 0 ? void 0 : _b.call(_a);\n        }\n    }\n    pushPick(callStream, callMetadata, callConfig) {\n        this.pickQueue.push({ callStream, callMetadata, callConfig });\n        this.callRefTimerRef();\n    }\n    /**\n     * Check the picker output for the given call and corresponding metadata,\n     * and take any relevant actions. Should not be called while iterating\n     * over pickQueue.\n     * @param callStream\n     * @param callMetadata\n     */\n    tryPick(callStream, callMetadata, callConfig) {\n        var _a, _b, _c;\n        const pickResult = this.currentPicker.pick({ metadata: callMetadata, extraPickInfo: callConfig.pickInformation });\n        logging_1.trace(constants_1.LogVerbosity.DEBUG, 'channel', 'Pick result: ' +\n            picker_1.PickResultType[pickResult.pickResultType] +\n            ' subchannel: ' + ((_a = pickResult.subchannel) === null || _a === void 0 ? void 0 : _a.getAddress()) +\n            ' status: ' + ((_b = pickResult.status) === null || _b === void 0 ? void 0 : _b.code) +\n            ' ' + ((_c = pickResult.status) === null || _c === void 0 ? void 0 : _c.details));\n        switch (pickResult.pickResultType) {\n            case picker_1.PickResultType.COMPLETE:\n                if (pickResult.subchannel === null) {\n                    callStream.cancelWithStatus(constants_1.Status.UNAVAILABLE, 'Request dropped by load balancing policy');\n                    // End the call with an error\n                }\n                else {\n                    /* If the subchannel is not in the READY state, that indicates a bug\n                     * somewhere in the load balancer or picker. So, we log an error and\n                     * queue the pick to be tried again later. */\n                    if (pickResult.subchannel.getConnectivityState() !==\n                        ConnectivityState.READY) {\n                        logging_1.log(constants_1.LogVerbosity.ERROR, 'Error: COMPLETE pick result subchannel ' +\n                            pickResult.subchannel.getAddress() +\n                            ' has state ' +\n                            ConnectivityState[pickResult.subchannel.getConnectivityState()]);\n                        this.pushPick(callStream, callMetadata, callConfig);\n                        break;\n                    }\n                    /* We need to clone the callMetadata here because the transparent\n                     * retry code in the promise resolution handler use the same\n                     * callMetadata object, so it needs to stay unmodified */\n                    callStream.filterStack\n                        .sendMetadata(Promise.resolve(callMetadata.clone()))\n                        .then((finalMetadata) => {\n                        var _a, _b, _c;\n                        const subchannelState = pickResult.subchannel.getConnectivityState();\n                        if (subchannelState === ConnectivityState.READY) {\n                            try {\n                                pickResult.subchannel.startCallStream(finalMetadata, callStream, (_a = pickResult.extraFilterFactory) !== null && _a !== void 0 ? _a : undefined);\n                                /* If we reach this point, the call stream has started\n                                 * successfully */\n                                (_b = callConfig.onCommitted) === null || _b === void 0 ? void 0 : _b.call(callConfig);\n                                (_c = pickResult.onCallStarted) === null || _c === void 0 ? void 0 : _c.call(pickResult);\n                            }\n                            catch (error) {\n                                if (error.code ===\n                                    'ERR_HTTP2_GOAWAY_SESSION') {\n                                    /* An error here indicates that something went wrong with\n                                     * the picked subchannel's http2 stream right before we\n                                     * tried to start the stream. We are handling a promise\n                                     * result here, so this is asynchronous with respect to the\n                                     * original tryPick call, so calling it again is not\n                                     * recursive. We call tryPick immediately instead of\n                                     * queueing this pick again because handling the queue is\n                                     * triggered by state changes, and we want to immediately\n                                     * check if the state has already changed since the\n                                     * previous tryPick call. We do this instead of cancelling\n                                     * the stream because the correct behavior may be\n                                     * re-queueing instead, based on the logic in the rest of\n                                     * tryPick */\n                                    logging_1.trace(constants_1.LogVerbosity.INFO, 'channel', 'Failed to start call on picked subchannel ' +\n                                        pickResult.subchannel.getAddress() +\n                                        ' with error ' +\n                                        error.message +\n                                        '. Retrying pick');\n                                    this.tryPick(callStream, callMetadata, callConfig);\n                                }\n                                else {\n                                    logging_1.trace(constants_1.LogVerbosity.INFO, 'channel', 'Failed to start call on picked subchanel ' +\n                                        pickResult.subchannel.getAddress() +\n                                        ' with error ' +\n                                        error.message +\n                                        '. Ending call');\n                                    callStream.cancelWithStatus(constants_1.Status.INTERNAL, `Failed to start HTTP/2 stream with error: ${error.message}`);\n                                }\n                            }\n                        }\n                        else {\n                            /* The logic for doing this here is the same as in the catch\n                             * block above */\n                            logging_1.trace(constants_1.LogVerbosity.INFO, 'channel', 'Picked subchannel ' +\n                                pickResult.subchannel.getAddress() +\n                                ' has state ' +\n                                ConnectivityState[subchannelState] +\n                                ' after metadata filters. Retrying pick');\n                            this.tryPick(callStream, callMetadata, callConfig);\n                        }\n                    }, (error) => {\n                        // We assume the error code isn't 0 (Status.OK)\n                        callStream.cancelWithStatus((typeof error.code === 'number') ? error.code : constants_1.Status.UNKNOWN, `Getting metadata from plugin failed with error: ${error.message}`);\n                    });\n                }\n                break;\n            case picker_1.PickResultType.QUEUE:\n                this.pushPick(callStream, callMetadata, callConfig);\n                break;\n            case picker_1.PickResultType.TRANSIENT_FAILURE:\n                if (callMetadata.getOptions().waitForReady) {\n                    this.pushPick(callStream, callMetadata, callConfig);\n                }\n                else {\n                    callStream.cancelWithStatus(pickResult.status.code, pickResult.status.details);\n                }\n                break;\n            case picker_1.PickResultType.DROP:\n                callStream.cancelWithStatus(pickResult.status.code, pickResult.status.details);\n                break;\n            default:\n                throw new Error(`Invalid state: unknown pickResultType ${pickResult.pickResultType}`);\n        }\n    }\n    removeConnectivityStateWatcher(watcherObject) {\n        const watcherIndex = this.connectivityStateWatchers.findIndex((value) => value === watcherObject);\n        if (watcherIndex >= 0) {\n            this.connectivityStateWatchers.splice(watcherIndex, 1);\n        }\n    }\n    updateState(newState) {\n        logging_1.trace(constants_1.LogVerbosity.DEBUG, 'connectivity_state', uri_parser_1.uriToString(this.target) +\n            ' ' +\n            ConnectivityState[this.connectivityState] +\n            ' -> ' +\n            ConnectivityState[newState]);\n        this.connectivityState = newState;\n        const watchersCopy = this.connectivityStateWatchers.slice();\n        for (const watcherObject of watchersCopy) {\n            if (newState !== watcherObject.currentState) {\n                if (watcherObject.timer) {\n                    clearTimeout(watcherObject.timer);\n                }\n                this.removeConnectivityStateWatcher(watcherObject);\n                watcherObject.callback();\n            }\n        }\n    }\n    tryGetConfig(stream, metadata) {\n        if (this.configSelector === null) {\n            /* This branch will only be taken at the beginning of the channel's life,\n             * before the resolver ever returns a result. So, the\n             * ResolvingLoadBalancer may be idle and if so it needs to be kicked\n             * because it now has a pending request. */\n            this.resolvingLoadBalancer.exitIdle();\n            this.configSelectionQueue.push({\n                callStream: stream,\n                callMetadata: metadata\n            });\n            this.callRefTimerRef();\n        }\n        else {\n            const callConfig = this.configSelector(stream.getMethod(), metadata);\n            if (callConfig.status === constants_1.Status.OK) {\n                this.tryPick(stream, metadata, callConfig);\n            }\n            else {\n                stream.cancelWithStatus(callConfig.status, \"Failed to route call to method \" + stream.getMethod());\n            }\n        }\n    }\n    _startCallStream(stream, metadata) {\n        this.tryGetConfig(stream, metadata.clone());\n    }\n    close() {\n        this.resolvingLoadBalancer.destroy();\n        this.updateState(ConnectivityState.SHUTDOWN);\n        clearInterval(this.callRefTimer);\n        this.subchannelPool.unrefUnusedSubchannels();\n    }\n    getTarget() {\n        return uri_parser_1.uriToString(this.target);\n    }\n    getConnectivityState(tryToConnect) {\n        const connectivityState = this.connectivityState;\n        if (tryToConnect) {\n            this.resolvingLoadBalancer.exitIdle();\n        }\n        return connectivityState;\n    }\n    watchConnectivityState(currentState, deadline, callback) {\n        if (this.connectivityState === ConnectivityState.SHUTDOWN) {\n            throw new Error('Channel has been shut down');\n        }\n        let timer = null;\n        if (deadline !== Infinity) {\n            const deadlineDate = deadline instanceof Date ? deadline : new Date(deadline);\n            const now = new Date();\n            if (deadline === -Infinity || deadlineDate <= now) {\n                process.nextTick(callback, new Error('Deadline passed without connectivity state change'));\n                return;\n            }\n            timer = setTimeout(() => {\n                this.removeConnectivityStateWatcher(watcherObject);\n                callback(new Error('Deadline passed without connectivity state change'));\n            }, deadlineDate.getTime() - now.getTime());\n        }\n        const watcherObject = {\n            currentState,\n            callback,\n            timer\n        };\n        this.connectivityStateWatchers.push(watcherObject);\n    }\n    createCall(method, deadline, host, parentCall, propagateFlags) {\n        if (typeof method !== 'string') {\n            throw new TypeError('Channel#createCall: method must be a string');\n        }\n        if (!(typeof deadline === 'number' || deadline instanceof Date)) {\n            throw new TypeError('Channel#createCall: deadline must be a number or Date');\n        }\n        if (this.connectivityState === ConnectivityState.SHUTDOWN) {\n            throw new Error('Channel has been shut down');\n        }\n        const callNumber = getNewCallNumber();\n        logging_1.trace(constants_1.LogVerbosity.DEBUG, 'channel', uri_parser_1.uriToString(this.target) +\n            ' createCall [' +\n            callNumber +\n            '] method=\"' +\n            method +\n            '\", deadline=' +\n            deadline);\n        const finalOptions = {\n            deadline: deadline,\n            flags: propagateFlags !== null && propagateFlags !== void 0 ? propagateFlags : constants_1.Propagate.DEFAULTS,\n            host: host !== null && host !== void 0 ? host : this.defaultAuthority,\n            parentCall: parentCall,\n        };\n        const stream = new call_stream_1.Http2CallStream(method, this, finalOptions, this.filterStackFactory, this.credentials._getCallCredentials(), callNumber);\n        return stream;\n    }\n}\nexports.ChannelImplementation = ChannelImplementation;\n//# sourceMappingURL=channel.js.map"]},"metadata":{},"sourceType":"script"}