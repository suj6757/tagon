{"ast":null,"code":"\"use strict\";\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.CallCredentialsFilterFactory = exports.CallCredentialsFilter = void 0;\n\nconst filter_1 = require(\"./filter\");\n\nconst constants_1 = require(\"./constants\");\n\nconst uri_parser_1 = require(\"./uri-parser\");\n\nclass CallCredentialsFilter extends filter_1.BaseFilter {\n  constructor(channel, stream) {\n    var _a, _b;\n\n    super();\n    this.channel = channel;\n    this.stream = stream;\n    this.channel = channel;\n    this.stream = stream;\n    const splitPath = stream.getMethod().split('/');\n    let serviceName = '';\n    /* The standard path format is \"/{serviceName}/{methodName}\", so if we split\n     * by '/', the first item should be empty and the second should be the\n     * service name */\n\n    if (splitPath.length >= 2) {\n      serviceName = splitPath[1];\n    }\n\n    const hostname = (_b = (_a = uri_parser_1.splitHostPort(stream.getHost())) === null || _a === void 0 ? void 0 : _a.host) !== null && _b !== void 0 ? _b : 'localhost';\n    /* Currently, call credentials are only allowed on HTTPS connections, so we\n     * can assume that the scheme is \"https\" */\n\n    this.serviceUrl = `https://${hostname}/${serviceName}`;\n  }\n\n  async sendMetadata(metadata) {\n    const credentials = this.stream.getCredentials();\n    const credsMetadata = credentials.generateMetadata({\n      service_url: this.serviceUrl\n    });\n    const resultMetadata = await metadata;\n\n    try {\n      resultMetadata.merge(await credsMetadata);\n    } catch (error) {\n      this.stream.cancelWithStatus(constants_1.Status.UNAUTHENTICATED, `Failed to retrieve auth metadata with error: ${error.message}`);\n      return Promise.reject('Failed to retrieve auth metadata');\n    }\n\n    if (resultMetadata.get('authorization').length > 1) {\n      this.stream.cancelWithStatus(constants_1.Status.INTERNAL, '\"authorization\" metadata cannot have multiple values');\n      return Promise.reject('\"authorization\" metadata cannot have multiple values');\n    }\n\n    return resultMetadata;\n  }\n\n}\n\nexports.CallCredentialsFilter = CallCredentialsFilter;\n\nclass CallCredentialsFilterFactory {\n  constructor(channel) {\n    this.channel = channel;\n    this.channel = channel;\n  }\n\n  createFilter(callStream) {\n    return new CallCredentialsFilter(this.channel, callStream);\n  }\n\n}\n\nexports.CallCredentialsFilterFactory = CallCredentialsFilterFactory;","map":{"version":3,"sources":["../../src/call-credentials-filter.ts"],"names":[],"mappings":";AAAA;;;;;;;;;;;;;;;AAeG;;;;;;;AAIH,MAAA,QAAA,GAAA,OAAA,CAAA,UAAA,CAAA;;AAEA,MAAA,WAAA,GAAA,OAAA,CAAA,aAAA,CAAA;;AACA,MAAA,YAAA,GAAA,OAAA,CAAA,cAAA,CAAA;;AAGA,MAAa,qBAAb,SAA2C,QAAA,CAAA,UAA3C,CAAqD;AAEnD,EAAA,WAAA,CACmB,OADnB,EAEmB,MAFnB,EAE+B;;;AAE7B;AAHiB,SAAA,OAAA,GAAA,OAAA;AACA,SAAA,MAAA,GAAA,MAAA;AAGjB,SAAK,OAAL,GAAe,OAAf;AACA,SAAK,MAAL,GAAc,MAAd;AACA,UAAM,SAAS,GAAa,MAAM,CAAC,SAAP,GAAmB,KAAnB,CAAyB,GAAzB,CAA5B;AACA,QAAI,WAAW,GAAG,EAAlB;AACA;;AAEkB;;AAClB,QAAI,SAAS,CAAC,MAAV,IAAoB,CAAxB,EAA2B;AACzB,MAAA,WAAW,GAAG,SAAS,CAAC,CAAD,CAAvB;AACD;;AACD,UAAM,QAAQ,GAAA,CAAA,EAAA,GAAA,CAAA,EAAA,GAAG,YAAA,CAAA,aAAA,CAAc,MAAM,CAAC,OAAP,EAAd,CAAH,MAAkC,IAAlC,IAAkC,EAAA,KAAA,KAAA,CAAlC,GAAkC,KAAA,CAAlC,GAAkC,EAAA,CAAE,IAApC,MAAwC,IAAxC,IAAwC,EAAA,KAAA,KAAA,CAAxC,GAAwC,EAAxC,GAA4C,WAA1D;AACA;AAC2C;;AAC3C,SAAK,UAAL,GAAkB,WAAW,QAAQ,IAAI,WAAW,EAApD;AACD;;AAEiB,QAAZ,YAAY,CAAC,QAAD,EAA4B;AAC5C,UAAM,WAAW,GAAG,KAAK,MAAL,CAAY,cAAZ,EAApB;AACA,UAAM,aAAa,GAAG,WAAW,CAAC,gBAAZ,CAA6B;AACjD,MAAA,WAAW,EAAE,KAAK;AAD+B,KAA7B,CAAtB;AAGA,UAAM,cAAc,GAAG,MAAM,QAA7B;;AACA,QAAI;AACF,MAAA,cAAc,CAAC,KAAf,CAAqB,MAAM,aAA3B;AACD,KAFD,CAEE,OAAO,KAAP,EAAc;AACd,WAAK,MAAL,CAAY,gBAAZ,CACE,WAAA,CAAA,MAAA,CAAO,eADT,EAEE,gDAAgD,KAAK,CAAC,OAAO,EAF/D;AAIA,aAAO,OAAO,CAAC,MAAR,CAAyB,kCAAzB,CAAP;AACD;;AACD,QAAI,cAAc,CAAC,GAAf,CAAmB,eAAnB,EAAoC,MAApC,GAA6C,CAAjD,EAAoD;AAClD,WAAK,MAAL,CAAY,gBAAZ,CACE,WAAA,CAAA,MAAA,CAAO,QADT,EAEE,sDAFF;AAIA,aAAO,OAAO,CAAC,MAAR,CAAyB,sDAAzB,CAAP;AACD;;AACD,WAAO,cAAP;AACD;;AA9CkD;;AAArD,OAAA,CAAA,qBAAA,GAAA,qBAAA;;AAiDA,MAAa,4BAAb,CAAyC;AAEvC,EAAA,WAAA,CAA6B,OAA7B,EAA6C;AAAhB,SAAA,OAAA,GAAA,OAAA;AAC3B,SAAK,OAAL,GAAe,OAAf;AACD;;AAED,EAAA,YAAY,CAAC,UAAD,EAAiB;AAC3B,WAAO,IAAI,qBAAJ,CAA0B,KAAK,OAA/B,EAAwC,UAAxC,CAAP;AACD;;AARsC;;AAAzC,OAAA,CAAA,4BAAA,GAAA,4BAAA","sourceRoot":"","sourcesContent":["\"use strict\";\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.CallCredentialsFilterFactory = exports.CallCredentialsFilter = void 0;\nconst filter_1 = require(\"./filter\");\nconst constants_1 = require(\"./constants\");\nconst uri_parser_1 = require(\"./uri-parser\");\nclass CallCredentialsFilter extends filter_1.BaseFilter {\n    constructor(channel, stream) {\n        var _a, _b;\n        super();\n        this.channel = channel;\n        this.stream = stream;\n        this.channel = channel;\n        this.stream = stream;\n        const splitPath = stream.getMethod().split('/');\n        let serviceName = '';\n        /* The standard path format is \"/{serviceName}/{methodName}\", so if we split\n         * by '/', the first item should be empty and the second should be the\n         * service name */\n        if (splitPath.length >= 2) {\n            serviceName = splitPath[1];\n        }\n        const hostname = (_b = (_a = uri_parser_1.splitHostPort(stream.getHost())) === null || _a === void 0 ? void 0 : _a.host) !== null && _b !== void 0 ? _b : 'localhost';\n        /* Currently, call credentials are only allowed on HTTPS connections, so we\n         * can assume that the scheme is \"https\" */\n        this.serviceUrl = `https://${hostname}/${serviceName}`;\n    }\n    async sendMetadata(metadata) {\n        const credentials = this.stream.getCredentials();\n        const credsMetadata = credentials.generateMetadata({\n            service_url: this.serviceUrl,\n        });\n        const resultMetadata = await metadata;\n        try {\n            resultMetadata.merge(await credsMetadata);\n        }\n        catch (error) {\n            this.stream.cancelWithStatus(constants_1.Status.UNAUTHENTICATED, `Failed to retrieve auth metadata with error: ${error.message}`);\n            return Promise.reject('Failed to retrieve auth metadata');\n        }\n        if (resultMetadata.get('authorization').length > 1) {\n            this.stream.cancelWithStatus(constants_1.Status.INTERNAL, '\"authorization\" metadata cannot have multiple values');\n            return Promise.reject('\"authorization\" metadata cannot have multiple values');\n        }\n        return resultMetadata;\n    }\n}\nexports.CallCredentialsFilter = CallCredentialsFilter;\nclass CallCredentialsFilterFactory {\n    constructor(channel) {\n        this.channel = channel;\n        this.channel = channel;\n    }\n    createFilter(callStream) {\n        return new CallCredentialsFilter(this.channel, callStream);\n    }\n}\nexports.CallCredentialsFilterFactory = CallCredentialsFilterFactory;\n//# sourceMappingURL=call-credentials-filter.js.map"]},"metadata":{},"sourceType":"script"}