{"ast":null,"code":"\"use strict\";\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ResolvingLoadBalancer = void 0;\n\nconst load_balancer_1 = require(\"./load-balancer\");\n\nconst service_config_1 = require(\"./service-config\");\n\nconst channel_1 = require(\"./channel\");\n\nconst resolver_1 = require(\"./resolver\");\n\nconst picker_1 = require(\"./picker\");\n\nconst backoff_timeout_1 = require(\"./backoff-timeout\");\n\nconst constants_1 = require(\"./constants\");\n\nconst metadata_1 = require(\"./metadata\");\n\nconst logging = require(\"./logging\");\n\nconst constants_2 = require(\"./constants\");\n\nconst uri_parser_1 = require(\"./uri-parser\");\n\nconst load_balancer_child_handler_1 = require(\"./load-balancer-child-handler\");\n\nconst TRACER_NAME = 'resolving_load_balancer';\n\nfunction trace(text) {\n  logging.trace(constants_2.LogVerbosity.DEBUG, TRACER_NAME, text);\n}\n\nconst DEFAULT_LOAD_BALANCER_NAME = 'pick_first';\n\nfunction getDefaultConfigSelector(serviceConfig) {\n  return function defaultConfigSelector(methodName, metadata) {\n    var _a, _b;\n\n    const splitName = methodName.split('/').filter(x => x.length > 0);\n    const service = (_a = splitName[0]) !== null && _a !== void 0 ? _a : '';\n    const method = (_b = splitName[1]) !== null && _b !== void 0 ? _b : '';\n\n    if (serviceConfig && serviceConfig.methodConfig) {\n      for (const methodConfig of serviceConfig.methodConfig) {\n        for (const name of methodConfig.name) {\n          if (name.service === service && (name.method === undefined || name.method === method)) {\n            return {\n              methodConfig: methodConfig,\n              pickInformation: {},\n              status: constants_1.Status.OK\n            };\n          }\n        }\n      }\n    }\n\n    return {\n      methodConfig: {\n        name: []\n      },\n      pickInformation: {},\n      status: constants_1.Status.OK\n    };\n  };\n}\n\nclass ResolvingLoadBalancer {\n  /**\n   * Wrapper class that behaves like a `LoadBalancer` and also handles name\n   * resolution internally.\n   * @param target The address of the backend to connect to.\n   * @param channelControlHelper `ChannelControlHelper` instance provided by\n   *     this load balancer's owner.\n   * @param defaultServiceConfig The default service configuration to be used\n   *     if none is provided by the name resolver. A `null` value indicates\n   *     that the default behavior should be the default unconfigured behavior.\n   *     In practice, that means using the \"pick first\" load balancer\n   *     implmentation\n   */\n  constructor(target, channelControlHelper, channelOptions, onSuccessfulResolution, onFailedResolution) {\n    this.target = target;\n    this.channelControlHelper = channelControlHelper;\n    this.channelOptions = channelOptions;\n    this.onSuccessfulResolution = onSuccessfulResolution;\n    this.onFailedResolution = onFailedResolution;\n    this.latestChildState = channel_1.ConnectivityState.IDLE;\n    this.latestChildPicker = new picker_1.QueuePicker(this);\n    /**\n     * This resolving load balancer's current connectivity state.\n     */\n\n    this.currentState = channel_1.ConnectivityState.IDLE;\n    /**\n     * The service config object from the last successful resolution, if\n     * available. A value of null indicates that we have not yet received a valid\n     * service config from the resolver.\n     */\n\n    this.previousServiceConfig = null;\n    /**\n     * Indicates whether we should attempt to resolve again after the backoff\n     * timer runs out.\n     */\n\n    this.continueResolving = false;\n\n    if (channelOptions['grpc.service_config']) {\n      this.defaultServiceConfig = service_config_1.validateServiceConfig(JSON.parse(channelOptions['grpc.service_config']));\n    } else {\n      this.defaultServiceConfig = {\n        loadBalancingConfig: [],\n        methodConfig: []\n      };\n    }\n\n    this.updateState(channel_1.ConnectivityState.IDLE, new picker_1.QueuePicker(this));\n    this.childLoadBalancer = new load_balancer_child_handler_1.ChildLoadBalancerHandler({\n      createSubchannel: channelControlHelper.createSubchannel.bind(channelControlHelper),\n      requestReresolution: () => {\n        /* If the backoffTimeout is running, we're still backing off from\n         * making resolve requests, so we shouldn't make another one here.\n         * In that case, the backoff timer callback will call\n         * updateResolution */\n        if (this.backoffTimeout.isRunning()) {\n          this.continueResolving = true;\n        } else {\n          this.updateResolution();\n        }\n      },\n      updateState: (newState, picker) => {\n        this.latestChildState = newState;\n        this.latestChildPicker = picker;\n        this.updateState(newState, picker);\n      }\n    });\n    this.innerResolver = resolver_1.createResolver(target, {\n      onSuccessfulResolution: (addressList, serviceConfig, serviceConfigError, configSelector, attributes) => {\n        var _a;\n\n        let workingServiceConfig = null;\n        /* This first group of conditionals implements the algorithm described\n         * in https://github.com/grpc/proposal/blob/master/A21-service-config-error-handling.md\n         * in the section called \"Behavior on receiving a new gRPC Config\".\n         */\n\n        if (serviceConfig === null) {\n          // Step 4 and 5\n          if (serviceConfigError === null) {\n            // Step 5\n            this.previousServiceConfig = null;\n            workingServiceConfig = this.defaultServiceConfig;\n          } else {\n            // Step 4\n            if (this.previousServiceConfig === null) {\n              // Step 4.ii\n              this.handleResolutionFailure(serviceConfigError);\n            } else {\n              // Step 4.i\n              workingServiceConfig = this.previousServiceConfig;\n            }\n          }\n        } else {\n          // Step 3\n          workingServiceConfig = serviceConfig;\n          this.previousServiceConfig = serviceConfig;\n        }\n\n        const workingConfigList = (_a = workingServiceConfig === null || workingServiceConfig === void 0 ? void 0 : workingServiceConfig.loadBalancingConfig) !== null && _a !== void 0 ? _a : [];\n        const loadBalancingConfig = load_balancer_1.getFirstUsableConfig(workingConfigList, true);\n\n        if (loadBalancingConfig === null) {\n          // There were load balancing configs but none are supported. This counts as a resolution failure\n          this.handleResolutionFailure({\n            code: constants_1.Status.UNAVAILABLE,\n            details: 'All load balancer options in service config are not compatible',\n            metadata: new metadata_1.Metadata()\n          });\n          return;\n        }\n\n        this.childLoadBalancer.updateAddressList(addressList, loadBalancingConfig, attributes);\n        const finalServiceConfig = workingServiceConfig !== null && workingServiceConfig !== void 0 ? workingServiceConfig : this.defaultServiceConfig;\n        this.onSuccessfulResolution(configSelector !== null && configSelector !== void 0 ? configSelector : getDefaultConfigSelector(finalServiceConfig));\n      },\n      onError: error => {\n        this.handleResolutionFailure(error);\n      }\n    }, channelOptions);\n    this.backoffTimeout = new backoff_timeout_1.BackoffTimeout(() => {\n      if (this.continueResolving) {\n        this.updateResolution();\n        this.continueResolving = false;\n      } else {\n        this.updateState(this.latestChildState, this.latestChildPicker);\n      }\n    });\n    this.backoffTimeout.unref();\n  }\n\n  updateResolution() {\n    this.innerResolver.updateResolution();\n\n    if (this.currentState === channel_1.ConnectivityState.IDLE) {\n      this.updateState(channel_1.ConnectivityState.CONNECTING, new picker_1.QueuePicker(this));\n    }\n  }\n\n  updateState(connectivityState, picker) {\n    trace(uri_parser_1.uriToString(this.target) + ' ' + channel_1.ConnectivityState[this.currentState] + ' -> ' + channel_1.ConnectivityState[connectivityState]); // Ensure that this.exitIdle() is called by the picker\n\n    if (connectivityState === channel_1.ConnectivityState.IDLE) {\n      picker = new picker_1.QueuePicker(this);\n    }\n\n    this.currentState = connectivityState;\n    this.channelControlHelper.updateState(connectivityState, picker);\n  }\n\n  handleResolutionFailure(error) {\n    if (this.latestChildState === channel_1.ConnectivityState.IDLE) {\n      this.updateState(channel_1.ConnectivityState.TRANSIENT_FAILURE, new picker_1.UnavailablePicker(error));\n      this.onFailedResolution(error);\n    }\n\n    this.backoffTimeout.runOnce();\n  }\n\n  exitIdle() {\n    this.childLoadBalancer.exitIdle();\n\n    if (this.currentState === channel_1.ConnectivityState.IDLE) {\n      if (this.backoffTimeout.isRunning()) {\n        this.continueResolving = true;\n      } else {\n        this.updateResolution();\n      }\n\n      this.updateState(channel_1.ConnectivityState.CONNECTING, new picker_1.QueuePicker(this));\n    }\n  }\n\n  updateAddressList(addressList, lbConfig) {\n    throw new Error('updateAddressList not supported on ResolvingLoadBalancer');\n  }\n\n  resetBackoff() {\n    this.backoffTimeout.reset();\n    this.childLoadBalancer.resetBackoff();\n  }\n\n  destroy() {\n    this.childLoadBalancer.destroy();\n    this.innerResolver.destroy();\n    this.updateState(channel_1.ConnectivityState.SHUTDOWN, new picker_1.UnavailablePicker());\n  }\n\n  getTypeName() {\n    return 'resolving_load_balancer';\n  }\n\n}\n\nexports.ResolvingLoadBalancer = ResolvingLoadBalancer;","map":{"version":3,"sources":["../../src/resolving-load-balancer.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ResolvingLoadBalancer = void 0;\nconst load_balancer_1 = require(\"./load-balancer\");\nconst service_config_1 = require(\"./service-config\");\nconst channel_1 = require(\"./channel\");\nconst resolver_1 = require(\"./resolver\");\nconst picker_1 = require(\"./picker\");\nconst backoff_timeout_1 = require(\"./backoff-timeout\");\nconst constants_1 = require(\"./constants\");\nconst metadata_1 = require(\"./metadata\");\nconst logging = require(\"./logging\");\nconst constants_2 = require(\"./constants\");\nconst uri_parser_1 = require(\"./uri-parser\");\nconst load_balancer_child_handler_1 = require(\"./load-balancer-child-handler\");\nconst TRACER_NAME = 'resolving_load_balancer';\nfunction trace(text) {\n    logging.trace(constants_2.LogVerbosity.DEBUG, TRACER_NAME, text);\n}\nconst DEFAULT_LOAD_BALANCER_NAME = 'pick_first';\nfunction getDefaultConfigSelector(serviceConfig) {\n    return function defaultConfigSelector(methodName, metadata) {\n        var _a, _b;\n        const splitName = methodName.split('/').filter(x => x.length > 0);\n        const service = (_a = splitName[0]) !== null && _a !== void 0 ? _a : '';\n        const method = (_b = splitName[1]) !== null && _b !== void 0 ? _b : '';\n        if (serviceConfig && serviceConfig.methodConfig) {\n            for (const methodConfig of serviceConfig.methodConfig) {\n                for (const name of methodConfig.name) {\n                    if (name.service === service && (name.method === undefined || name.method === method)) {\n                        return {\n                            methodConfig: methodConfig,\n                            pickInformation: {},\n                            status: constants_1.Status.OK\n                        };\n                    }\n                }\n            }\n        }\n        return {\n            methodConfig: { name: [] },\n            pickInformation: {},\n            status: constants_1.Status.OK\n        };\n    };\n}\nclass ResolvingLoadBalancer {\n    /**\n     * Wrapper class that behaves like a `LoadBalancer` and also handles name\n     * resolution internally.\n     * @param target The address of the backend to connect to.\n     * @param channelControlHelper `ChannelControlHelper` instance provided by\n     *     this load balancer's owner.\n     * @param defaultServiceConfig The default service configuration to be used\n     *     if none is provided by the name resolver. A `null` value indicates\n     *     that the default behavior should be the default unconfigured behavior.\n     *     In practice, that means using the \"pick first\" load balancer\n     *     implmentation\n     */\n    constructor(target, channelControlHelper, channelOptions, onSuccessfulResolution, onFailedResolution) {\n        this.target = target;\n        this.channelControlHelper = channelControlHelper;\n        this.channelOptions = channelOptions;\n        this.onSuccessfulResolution = onSuccessfulResolution;\n        this.onFailedResolution = onFailedResolution;\n        this.latestChildState = channel_1.ConnectivityState.IDLE;\n        this.latestChildPicker = new picker_1.QueuePicker(this);\n        /**\n         * This resolving load balancer's current connectivity state.\n         */\n        this.currentState = channel_1.ConnectivityState.IDLE;\n        /**\n         * The service config object from the last successful resolution, if\n         * available. A value of null indicates that we have not yet received a valid\n         * service config from the resolver.\n         */\n        this.previousServiceConfig = null;\n        /**\n         * Indicates whether we should attempt to resolve again after the backoff\n         * timer runs out.\n         */\n        this.continueResolving = false;\n        if (channelOptions['grpc.service_config']) {\n            this.defaultServiceConfig = service_config_1.validateServiceConfig(JSON.parse(channelOptions['grpc.service_config']));\n        }\n        else {\n            this.defaultServiceConfig = {\n                loadBalancingConfig: [],\n                methodConfig: [],\n            };\n        }\n        this.updateState(channel_1.ConnectivityState.IDLE, new picker_1.QueuePicker(this));\n        this.childLoadBalancer = new load_balancer_child_handler_1.ChildLoadBalancerHandler({\n            createSubchannel: channelControlHelper.createSubchannel.bind(channelControlHelper),\n            requestReresolution: () => {\n                /* If the backoffTimeout is running, we're still backing off from\n                 * making resolve requests, so we shouldn't make another one here.\n                 * In that case, the backoff timer callback will call\n                 * updateResolution */\n                if (this.backoffTimeout.isRunning()) {\n                    this.continueResolving = true;\n                }\n                else {\n                    this.updateResolution();\n                }\n            },\n            updateState: (newState, picker) => {\n                this.latestChildState = newState;\n                this.latestChildPicker = picker;\n                this.updateState(newState, picker);\n            },\n        });\n        this.innerResolver = resolver_1.createResolver(target, {\n            onSuccessfulResolution: (addressList, serviceConfig, serviceConfigError, configSelector, attributes) => {\n                var _a;\n                let workingServiceConfig = null;\n                /* This first group of conditionals implements the algorithm described\n                 * in https://github.com/grpc/proposal/blob/master/A21-service-config-error-handling.md\n                 * in the section called \"Behavior on receiving a new gRPC Config\".\n                 */\n                if (serviceConfig === null) {\n                    // Step 4 and 5\n                    if (serviceConfigError === null) {\n                        // Step 5\n                        this.previousServiceConfig = null;\n                        workingServiceConfig = this.defaultServiceConfig;\n                    }\n                    else {\n                        // Step 4\n                        if (this.previousServiceConfig === null) {\n                            // Step 4.ii\n                            this.handleResolutionFailure(serviceConfigError);\n                        }\n                        else {\n                            // Step 4.i\n                            workingServiceConfig = this.previousServiceConfig;\n                        }\n                    }\n                }\n                else {\n                    // Step 3\n                    workingServiceConfig = serviceConfig;\n                    this.previousServiceConfig = serviceConfig;\n                }\n                const workingConfigList = (_a = workingServiceConfig === null || workingServiceConfig === void 0 ? void 0 : workingServiceConfig.loadBalancingConfig) !== null && _a !== void 0 ? _a : [];\n                const loadBalancingConfig = load_balancer_1.getFirstUsableConfig(workingConfigList, true);\n                if (loadBalancingConfig === null) {\n                    // There were load balancing configs but none are supported. This counts as a resolution failure\n                    this.handleResolutionFailure({\n                        code: constants_1.Status.UNAVAILABLE,\n                        details: 'All load balancer options in service config are not compatible',\n                        metadata: new metadata_1.Metadata(),\n                    });\n                    return;\n                }\n                this.childLoadBalancer.updateAddressList(addressList, loadBalancingConfig, attributes);\n                const finalServiceConfig = workingServiceConfig !== null && workingServiceConfig !== void 0 ? workingServiceConfig : this.defaultServiceConfig;\n                this.onSuccessfulResolution(configSelector !== null && configSelector !== void 0 ? configSelector : getDefaultConfigSelector(finalServiceConfig));\n            },\n            onError: (error) => {\n                this.handleResolutionFailure(error);\n            },\n        }, channelOptions);\n        this.backoffTimeout = new backoff_timeout_1.BackoffTimeout(() => {\n            if (this.continueResolving) {\n                this.updateResolution();\n                this.continueResolving = false;\n            }\n            else {\n                this.updateState(this.latestChildState, this.latestChildPicker);\n            }\n        });\n        this.backoffTimeout.unref();\n    }\n    updateResolution() {\n        this.innerResolver.updateResolution();\n        if (this.currentState === channel_1.ConnectivityState.IDLE) {\n            this.updateState(channel_1.ConnectivityState.CONNECTING, new picker_1.QueuePicker(this));\n        }\n    }\n    updateState(connectivityState, picker) {\n        trace(uri_parser_1.uriToString(this.target) +\n            ' ' +\n            channel_1.ConnectivityState[this.currentState] +\n            ' -> ' +\n            channel_1.ConnectivityState[connectivityState]);\n        // Ensure that this.exitIdle() is called by the picker\n        if (connectivityState === channel_1.ConnectivityState.IDLE) {\n            picker = new picker_1.QueuePicker(this);\n        }\n        this.currentState = connectivityState;\n        this.channelControlHelper.updateState(connectivityState, picker);\n    }\n    handleResolutionFailure(error) {\n        if (this.latestChildState === channel_1.ConnectivityState.IDLE) {\n            this.updateState(channel_1.ConnectivityState.TRANSIENT_FAILURE, new picker_1.UnavailablePicker(error));\n            this.onFailedResolution(error);\n        }\n        this.backoffTimeout.runOnce();\n    }\n    exitIdle() {\n        this.childLoadBalancer.exitIdle();\n        if (this.currentState === channel_1.ConnectivityState.IDLE) {\n            if (this.backoffTimeout.isRunning()) {\n                this.continueResolving = true;\n            }\n            else {\n                this.updateResolution();\n            }\n            this.updateState(channel_1.ConnectivityState.CONNECTING, new picker_1.QueuePicker(this));\n        }\n    }\n    updateAddressList(addressList, lbConfig) {\n        throw new Error('updateAddressList not supported on ResolvingLoadBalancer');\n    }\n    resetBackoff() {\n        this.backoffTimeout.reset();\n        this.childLoadBalancer.resetBackoff();\n    }\n    destroy() {\n        this.childLoadBalancer.destroy();\n        this.innerResolver.destroy();\n        this.updateState(channel_1.ConnectivityState.SHUTDOWN, new picker_1.UnavailablePicker());\n    }\n    getTypeName() {\n        return 'resolving_load_balancer';\n    }\n}\nexports.ResolvingLoadBalancer = ResolvingLoadBalancer;\n//# sourceMappingURL=resolving-load-balancer.js.map"]},"metadata":{},"sourceType":"script"}