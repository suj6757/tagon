{"ast":null,"code":"\"use strict\";\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.BackoffTimeout = void 0;\nconst INITIAL_BACKOFF_MS = 1000;\nconst BACKOFF_MULTIPLIER = 1.6;\nconst MAX_BACKOFF_MS = 120000;\nconst BACKOFF_JITTER = 0.2;\n/**\n * Get a number uniformly at random in the range [min, max)\n * @param min\n * @param max\n */\n\nfunction uniformRandom(min, max) {\n  return Math.random() * (max - min) + min;\n}\n\nclass BackoffTimeout {\n  constructor(callback, options) {\n    this.callback = callback;\n    this.initialDelay = INITIAL_BACKOFF_MS;\n    this.multiplier = BACKOFF_MULTIPLIER;\n    this.maxDelay = MAX_BACKOFF_MS;\n    this.jitter = BACKOFF_JITTER;\n    this.running = false;\n    this.hasRef = true;\n\n    if (options) {\n      if (options.initialDelay) {\n        this.initialDelay = options.initialDelay;\n      }\n\n      if (options.multiplier) {\n        this.multiplier = options.multiplier;\n      }\n\n      if (options.jitter) {\n        this.jitter = options.jitter;\n      }\n\n      if (options.maxDelay) {\n        this.maxDelay = options.maxDelay;\n      }\n    }\n\n    this.nextDelay = this.initialDelay;\n    this.timerId = setTimeout(() => {}, 0);\n    clearTimeout(this.timerId);\n  }\n  /**\n   * Call the callback after the current amount of delay time\n   */\n\n\n  runOnce() {\n    var _a, _b;\n\n    this.running = true;\n    this.timerId = setTimeout(() => {\n      this.callback();\n      this.running = false;\n    }, this.nextDelay);\n\n    if (!this.hasRef) {\n      (_b = (_a = this.timerId).unref) === null || _b === void 0 ? void 0 : _b.call(_a);\n    }\n\n    const nextBackoff = Math.min(this.nextDelay * this.multiplier, this.maxDelay);\n    const jitterMagnitude = nextBackoff * this.jitter;\n    this.nextDelay = nextBackoff + uniformRandom(-jitterMagnitude, jitterMagnitude);\n  }\n  /**\n   * Stop the timer. The callback will not be called until `runOnce` is called\n   * again.\n   */\n\n\n  stop() {\n    clearTimeout(this.timerId);\n    this.running = false;\n  }\n  /**\n   * Reset the delay time to its initial value.\n   */\n\n\n  reset() {\n    this.nextDelay = this.initialDelay;\n  }\n\n  isRunning() {\n    return this.running;\n  }\n\n  ref() {\n    var _a, _b;\n\n    this.hasRef = true;\n    (_b = (_a = this.timerId).ref) === null || _b === void 0 ? void 0 : _b.call(_a);\n  }\n\n  unref() {\n    var _a, _b;\n\n    this.hasRef = false;\n    (_b = (_a = this.timerId).unref) === null || _b === void 0 ? void 0 : _b.call(_a);\n  }\n\n}\n\nexports.BackoffTimeout = BackoffTimeout;","map":{"version":3,"sources":["../../src/backoff-timeout.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.BackoffTimeout = void 0;\nconst INITIAL_BACKOFF_MS = 1000;\nconst BACKOFF_MULTIPLIER = 1.6;\nconst MAX_BACKOFF_MS = 120000;\nconst BACKOFF_JITTER = 0.2;\n/**\n * Get a number uniformly at random in the range [min, max)\n * @param min\n * @param max\n */\nfunction uniformRandom(min, max) {\n    return Math.random() * (max - min) + min;\n}\nclass BackoffTimeout {\n    constructor(callback, options) {\n        this.callback = callback;\n        this.initialDelay = INITIAL_BACKOFF_MS;\n        this.multiplier = BACKOFF_MULTIPLIER;\n        this.maxDelay = MAX_BACKOFF_MS;\n        this.jitter = BACKOFF_JITTER;\n        this.running = false;\n        this.hasRef = true;\n        if (options) {\n            if (options.initialDelay) {\n                this.initialDelay = options.initialDelay;\n            }\n            if (options.multiplier) {\n                this.multiplier = options.multiplier;\n            }\n            if (options.jitter) {\n                this.jitter = options.jitter;\n            }\n            if (options.maxDelay) {\n                this.maxDelay = options.maxDelay;\n            }\n        }\n        this.nextDelay = this.initialDelay;\n        this.timerId = setTimeout(() => { }, 0);\n        clearTimeout(this.timerId);\n    }\n    /**\n     * Call the callback after the current amount of delay time\n     */\n    runOnce() {\n        var _a, _b;\n        this.running = true;\n        this.timerId = setTimeout(() => {\n            this.callback();\n            this.running = false;\n        }, this.nextDelay);\n        if (!this.hasRef) {\n            (_b = (_a = this.timerId).unref) === null || _b === void 0 ? void 0 : _b.call(_a);\n        }\n        const nextBackoff = Math.min(this.nextDelay * this.multiplier, this.maxDelay);\n        const jitterMagnitude = nextBackoff * this.jitter;\n        this.nextDelay =\n            nextBackoff + uniformRandom(-jitterMagnitude, jitterMagnitude);\n    }\n    /**\n     * Stop the timer. The callback will not be called until `runOnce` is called\n     * again.\n     */\n    stop() {\n        clearTimeout(this.timerId);\n        this.running = false;\n    }\n    /**\n     * Reset the delay time to its initial value.\n     */\n    reset() {\n        this.nextDelay = this.initialDelay;\n    }\n    isRunning() {\n        return this.running;\n    }\n    ref() {\n        var _a, _b;\n        this.hasRef = true;\n        (_b = (_a = this.timerId).ref) === null || _b === void 0 ? void 0 : _b.call(_a);\n    }\n    unref() {\n        var _a, _b;\n        this.hasRef = false;\n        (_b = (_a = this.timerId).unref) === null || _b === void 0 ? void 0 : _b.call(_a);\n    }\n}\nexports.BackoffTimeout = BackoffTimeout;\n//# sourceMappingURL=backoff-timeout.js.map"]},"metadata":{},"sourceType":"script"}