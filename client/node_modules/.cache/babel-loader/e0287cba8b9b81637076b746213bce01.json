{"ast":null,"code":"\"use strict\";\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getProxiedConnection = exports.mapProxyName = void 0;\n\nconst logging_1 = require(\"./logging\");\n\nconst constants_1 = require(\"./constants\");\n\nconst resolver_1 = require(\"./resolver\");\n\nconst http = require(\"http\");\n\nconst tls = require(\"tls\");\n\nconst logging = require(\"./logging\");\n\nconst subchannel_1 = require(\"./subchannel\");\n\nconst uri_parser_1 = require(\"./uri-parser\");\n\nconst url_1 = require(\"url\");\n\nconst TRACER_NAME = 'proxy';\n\nfunction trace(text) {\n  logging.trace(constants_1.LogVerbosity.DEBUG, TRACER_NAME, text);\n}\n\nfunction getProxyInfo() {\n  let proxyEnv = '';\n  let envVar = '';\n  /* Prefer using 'grpc_proxy'. Fallback on 'http_proxy' if it is not set.\n   * Also prefer using 'https_proxy' with fallback on 'http_proxy'. The\n   * fallback behavior can be removed if there's a demand for it.\n   */\n\n  if (process.env.grpc_proxy) {\n    envVar = 'grpc_proxy';\n    proxyEnv = process.env.grpc_proxy;\n  } else if (process.env.https_proxy) {\n    envVar = 'https_proxy';\n    proxyEnv = process.env.https_proxy;\n  } else if (process.env.http_proxy) {\n    envVar = 'http_proxy';\n    proxyEnv = process.env.http_proxy;\n  } else {\n    return {};\n  }\n\n  let proxyUrl;\n\n  try {\n    proxyUrl = new url_1.URL(proxyEnv);\n  } catch (e) {\n    logging_1.log(constants_1.LogVerbosity.ERROR, `cannot parse value of \"${envVar}\" env var`);\n    return {};\n  }\n\n  if (proxyUrl.protocol !== 'http:') {\n    logging_1.log(constants_1.LogVerbosity.ERROR, `\"${proxyUrl.protocol}\" scheme not supported in proxy URI`);\n    return {};\n  }\n\n  let userCred = null;\n\n  if (proxyUrl.username) {\n    if (proxyUrl.password) {\n      logging_1.log(constants_1.LogVerbosity.INFO, 'userinfo found in proxy URI');\n      userCred = `${proxyUrl.username}:${proxyUrl.password}`;\n    } else {\n      userCred = proxyUrl.username;\n    }\n  }\n\n  const hostname = proxyUrl.hostname;\n  let port = proxyUrl.port;\n  /* The proxy URL uses the scheme \"http:\", which has a default port number of\n   * 80. We need to set that explicitly here if it is omitted because otherwise\n   * it will use gRPC's default port 443. */\n\n  if (port === '') {\n    port = '80';\n  }\n\n  const result = {\n    address: `${hostname}:${port}`\n  };\n\n  if (userCred) {\n    result.creds = userCred;\n  }\n\n  trace('Proxy server ' + result.address + ' set by environment variable ' + envVar);\n  return result;\n}\n\nfunction getNoProxyHostList() {\n  /* Prefer using 'no_grpc_proxy'. Fallback on 'no_proxy' if it is not set. */\n  let noProxyStr = process.env.no_grpc_proxy;\n  let envVar = 'no_grpc_proxy';\n\n  if (!noProxyStr) {\n    noProxyStr = process.env.no_proxy;\n    envVar = 'no_proxy';\n  }\n\n  if (noProxyStr) {\n    trace('No proxy server list set by environment variable ' + envVar);\n    return noProxyStr.split(',');\n  } else {\n    return [];\n  }\n}\n\nfunction mapProxyName(target, options) {\n  var _a;\n\n  const noProxyResult = {\n    target: target,\n    extraOptions: {}\n  };\n\n  if (((_a = options['grpc.enable_http_proxy']) !== null && _a !== void 0 ? _a : 1) === 0) {\n    return noProxyResult;\n  }\n\n  const proxyInfo = getProxyInfo();\n\n  if (!proxyInfo.address) {\n    return noProxyResult;\n  }\n\n  const hostPort = uri_parser_1.splitHostPort(target.path);\n\n  if (!hostPort) {\n    return noProxyResult;\n  }\n\n  const serverHost = hostPort.host;\n\n  for (const host of getNoProxyHostList()) {\n    if (host === serverHost) {\n      trace('Not using proxy for target in no_proxy list: ' + uri_parser_1.uriToString(target));\n      return noProxyResult;\n    }\n  }\n\n  const extraOptions = {\n    'grpc.http_connect_target': uri_parser_1.uriToString(target)\n  };\n\n  if (proxyInfo.creds) {\n    extraOptions['grpc.http_connect_creds'] = proxyInfo.creds;\n  }\n\n  return {\n    target: {\n      scheme: 'dns',\n      path: proxyInfo.address\n    },\n    extraOptions: extraOptions\n  };\n}\n\nexports.mapProxyName = mapProxyName;\n\nfunction getProxiedConnection(address, channelOptions, connectionOptions) {\n  if (!('grpc.http_connect_target' in channelOptions)) {\n    return Promise.resolve({});\n  }\n\n  const realTarget = channelOptions['grpc.http_connect_target'];\n  const parsedTarget = uri_parser_1.parseUri(realTarget);\n\n  if (parsedTarget === null) {\n    return Promise.resolve({});\n  }\n\n  const options = {\n    method: 'CONNECT',\n    path: parsedTarget.path\n  }; // Connect to the subchannel address as a proxy\n\n  if (subchannel_1.isTcpSubchannelAddress(address)) {\n    options.host = address.host;\n    options.port = address.port;\n  } else {\n    options.socketPath = address.path;\n  }\n\n  if ('grpc.http_connect_creds' in channelOptions) {\n    options.headers = {\n      'Proxy-Authorization': 'Basic ' + Buffer.from(channelOptions['grpc.http_connect_creds']).toString('base64')\n    };\n  }\n\n  const proxyAddressString = subchannel_1.subchannelAddressToString(address);\n  trace('Using proxy ' + proxyAddressString + ' to connect to ' + options.path);\n  return new Promise((resolve, reject) => {\n    const request = http.request(options);\n    request.once('connect', (res, socket, head) => {\n      var _a;\n\n      request.removeAllListeners();\n      socket.removeAllListeners();\n\n      if (res.statusCode === 200) {\n        trace('Successfully connected to ' + options.path + ' through proxy ' + proxyAddressString);\n\n        if ('secureContext' in connectionOptions) {\n          /* The proxy is connecting to a TLS server, so upgrade this socket\n           * connection to a TLS connection.\n           * This is a workaround for https://github.com/nodejs/node/issues/32922\n           * See https://github.com/grpc/grpc-node/pull/1369 for more info. */\n          const targetPath = resolver_1.getDefaultAuthority(parsedTarget);\n          const hostPort = uri_parser_1.splitHostPort(targetPath);\n          const remoteHost = (_a = hostPort === null || hostPort === void 0 ? void 0 : hostPort.host) !== null && _a !== void 0 ? _a : targetPath;\n          const cts = tls.connect(Object.assign({\n            host: remoteHost,\n            servername: remoteHost,\n            socket: socket\n          }, connectionOptions), () => {\n            trace('Successfully established a TLS connection to ' + options.path + ' through proxy ' + proxyAddressString);\n            resolve({\n              socket: cts,\n              realTarget: parsedTarget\n            });\n          });\n          cts.on('error', () => {\n            reject();\n          });\n        } else {\n          resolve({\n            socket,\n            realTarget: parsedTarget\n          });\n        }\n      } else {\n        logging_1.log(constants_1.LogVerbosity.ERROR, 'Failed to connect to ' + options.path + ' through proxy ' + proxyAddressString + ' with status ' + res.statusCode);\n        reject();\n      }\n    });\n    request.once('error', err => {\n      request.removeAllListeners();\n      logging_1.log(constants_1.LogVerbosity.ERROR, 'Failed to connect to proxy ' + proxyAddressString + ' with error ' + err.message);\n      reject();\n    });\n    request.end();\n  });\n}\n\nexports.getProxiedConnection = getProxiedConnection;","map":{"version":3,"sources":["../../src/http_proxy.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.getProxiedConnection = exports.mapProxyName = void 0;\nconst logging_1 = require(\"./logging\");\nconst constants_1 = require(\"./constants\");\nconst resolver_1 = require(\"./resolver\");\nconst http = require(\"http\");\nconst tls = require(\"tls\");\nconst logging = require(\"./logging\");\nconst subchannel_1 = require(\"./subchannel\");\nconst uri_parser_1 = require(\"./uri-parser\");\nconst url_1 = require(\"url\");\nconst TRACER_NAME = 'proxy';\nfunction trace(text) {\n    logging.trace(constants_1.LogVerbosity.DEBUG, TRACER_NAME, text);\n}\nfunction getProxyInfo() {\n    let proxyEnv = '';\n    let envVar = '';\n    /* Prefer using 'grpc_proxy'. Fallback on 'http_proxy' if it is not set.\n     * Also prefer using 'https_proxy' with fallback on 'http_proxy'. The\n     * fallback behavior can be removed if there's a demand for it.\n     */\n    if (process.env.grpc_proxy) {\n        envVar = 'grpc_proxy';\n        proxyEnv = process.env.grpc_proxy;\n    }\n    else if (process.env.https_proxy) {\n        envVar = 'https_proxy';\n        proxyEnv = process.env.https_proxy;\n    }\n    else if (process.env.http_proxy) {\n        envVar = 'http_proxy';\n        proxyEnv = process.env.http_proxy;\n    }\n    else {\n        return {};\n    }\n    let proxyUrl;\n    try {\n        proxyUrl = new url_1.URL(proxyEnv);\n    }\n    catch (e) {\n        logging_1.log(constants_1.LogVerbosity.ERROR, `cannot parse value of \"${envVar}\" env var`);\n        return {};\n    }\n    if (proxyUrl.protocol !== 'http:') {\n        logging_1.log(constants_1.LogVerbosity.ERROR, `\"${proxyUrl.protocol}\" scheme not supported in proxy URI`);\n        return {};\n    }\n    let userCred = null;\n    if (proxyUrl.username) {\n        if (proxyUrl.password) {\n            logging_1.log(constants_1.LogVerbosity.INFO, 'userinfo found in proxy URI');\n            userCred = `${proxyUrl.username}:${proxyUrl.password}`;\n        }\n        else {\n            userCred = proxyUrl.username;\n        }\n    }\n    const hostname = proxyUrl.hostname;\n    let port = proxyUrl.port;\n    /* The proxy URL uses the scheme \"http:\", which has a default port number of\n     * 80. We need to set that explicitly here if it is omitted because otherwise\n     * it will use gRPC's default port 443. */\n    if (port === '') {\n        port = '80';\n    }\n    const result = {\n        address: `${hostname}:${port}`\n    };\n    if (userCred) {\n        result.creds = userCred;\n    }\n    trace('Proxy server ' + result.address + ' set by environment variable ' + envVar);\n    return result;\n}\nfunction getNoProxyHostList() {\n    /* Prefer using 'no_grpc_proxy'. Fallback on 'no_proxy' if it is not set. */\n    let noProxyStr = process.env.no_grpc_proxy;\n    let envVar = 'no_grpc_proxy';\n    if (!noProxyStr) {\n        noProxyStr = process.env.no_proxy;\n        envVar = 'no_proxy';\n    }\n    if (noProxyStr) {\n        trace('No proxy server list set by environment variable ' + envVar);\n        return noProxyStr.split(',');\n    }\n    else {\n        return [];\n    }\n}\nfunction mapProxyName(target, options) {\n    var _a;\n    const noProxyResult = {\n        target: target,\n        extraOptions: {},\n    };\n    if (((_a = options['grpc.enable_http_proxy']) !== null && _a !== void 0 ? _a : 1) === 0) {\n        return noProxyResult;\n    }\n    const proxyInfo = getProxyInfo();\n    if (!proxyInfo.address) {\n        return noProxyResult;\n    }\n    const hostPort = uri_parser_1.splitHostPort(target.path);\n    if (!hostPort) {\n        return noProxyResult;\n    }\n    const serverHost = hostPort.host;\n    for (const host of getNoProxyHostList()) {\n        if (host === serverHost) {\n            trace('Not using proxy for target in no_proxy list: ' + uri_parser_1.uriToString(target));\n            return noProxyResult;\n        }\n    }\n    const extraOptions = {\n        'grpc.http_connect_target': uri_parser_1.uriToString(target),\n    };\n    if (proxyInfo.creds) {\n        extraOptions['grpc.http_connect_creds'] = proxyInfo.creds;\n    }\n    return {\n        target: {\n            scheme: 'dns',\n            path: proxyInfo.address,\n        },\n        extraOptions: extraOptions,\n    };\n}\nexports.mapProxyName = mapProxyName;\nfunction getProxiedConnection(address, channelOptions, connectionOptions) {\n    if (!('grpc.http_connect_target' in channelOptions)) {\n        return Promise.resolve({});\n    }\n    const realTarget = channelOptions['grpc.http_connect_target'];\n    const parsedTarget = uri_parser_1.parseUri(realTarget);\n    if (parsedTarget === null) {\n        return Promise.resolve({});\n    }\n    const options = {\n        method: 'CONNECT',\n        path: parsedTarget.path,\n    };\n    // Connect to the subchannel address as a proxy\n    if (subchannel_1.isTcpSubchannelAddress(address)) {\n        options.host = address.host;\n        options.port = address.port;\n    }\n    else {\n        options.socketPath = address.path;\n    }\n    if ('grpc.http_connect_creds' in channelOptions) {\n        options.headers = {\n            'Proxy-Authorization': 'Basic ' +\n                Buffer.from(channelOptions['grpc.http_connect_creds']).toString('base64'),\n        };\n    }\n    const proxyAddressString = subchannel_1.subchannelAddressToString(address);\n    trace('Using proxy ' + proxyAddressString + ' to connect to ' + options.path);\n    return new Promise((resolve, reject) => {\n        const request = http.request(options);\n        request.once('connect', (res, socket, head) => {\n            var _a;\n            request.removeAllListeners();\n            socket.removeAllListeners();\n            if (res.statusCode === 200) {\n                trace('Successfully connected to ' +\n                    options.path +\n                    ' through proxy ' +\n                    proxyAddressString);\n                if ('secureContext' in connectionOptions) {\n                    /* The proxy is connecting to a TLS server, so upgrade this socket\n                     * connection to a TLS connection.\n                     * This is a workaround for https://github.com/nodejs/node/issues/32922\n                     * See https://github.com/grpc/grpc-node/pull/1369 for more info. */\n                    const targetPath = resolver_1.getDefaultAuthority(parsedTarget);\n                    const hostPort = uri_parser_1.splitHostPort(targetPath);\n                    const remoteHost = (_a = hostPort === null || hostPort === void 0 ? void 0 : hostPort.host) !== null && _a !== void 0 ? _a : targetPath;\n                    const cts = tls.connect(Object.assign({ host: remoteHost, servername: remoteHost, socket: socket }, connectionOptions), () => {\n                        trace('Successfully established a TLS connection to ' +\n                            options.path +\n                            ' through proxy ' +\n                            proxyAddressString);\n                        resolve({ socket: cts, realTarget: parsedTarget });\n                    });\n                    cts.on('error', () => {\n                        reject();\n                    });\n                }\n                else {\n                    resolve({\n                        socket,\n                        realTarget: parsedTarget,\n                    });\n                }\n            }\n            else {\n                logging_1.log(constants_1.LogVerbosity.ERROR, 'Failed to connect to ' +\n                    options.path +\n                    ' through proxy ' +\n                    proxyAddressString +\n                    ' with status ' +\n                    res.statusCode);\n                reject();\n            }\n        });\n        request.once('error', (err) => {\n            request.removeAllListeners();\n            logging_1.log(constants_1.LogVerbosity.ERROR, 'Failed to connect to proxy ' +\n                proxyAddressString +\n                ' with error ' +\n                err.message);\n            reject();\n        });\n        request.end();\n    });\n}\nexports.getProxiedConnection = getProxiedConnection;\n//# sourceMappingURL=http_proxy.js.map"]},"metadata":{},"sourceType":"script"}