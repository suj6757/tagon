{"ast":null,"code":"\"use strict\";\n/*\n * Copyright 2020 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.uriToString = exports.splitHostPort = exports.parseUri = void 0;\n/*\n * The groups correspond to URI parts as follows:\n * 1. scheme\n * 2. authority\n * 3. path\n */\n\nconst URI_REGEX = /^(?:([A-Za-z0-9+.-]+):)?(?:\\/\\/([^/]*)\\/)?(.+)$/;\n\nfunction parseUri(uriString) {\n  const parsedUri = URI_REGEX.exec(uriString);\n\n  if (parsedUri === null) {\n    return null;\n  }\n\n  return {\n    scheme: parsedUri[1],\n    authority: parsedUri[2],\n    path: parsedUri[3]\n  };\n}\n\nexports.parseUri = parseUri;\nconst NUMBER_REGEX = /^\\d+$/;\n\nfunction splitHostPort(path) {\n  if (path.startsWith('[')) {\n    const hostEnd = path.indexOf(']');\n\n    if (hostEnd === -1) {\n      return null;\n    }\n\n    const host = path.substring(1, hostEnd);\n    /* Only an IPv6 address should be in bracketed notation, and an IPv6\n     * address should have at least one colon */\n\n    if (host.indexOf(':') === -1) {\n      return null;\n    }\n\n    if (path.length > hostEnd + 1) {\n      if (path[hostEnd + 1] === ':') {\n        const portString = path.substring(hostEnd + 2);\n\n        if (NUMBER_REGEX.test(portString)) {\n          return {\n            host: host,\n            port: +portString\n          };\n        } else {\n          return null;\n        }\n      } else {\n        return null;\n      }\n    } else {\n      return {\n        host\n      };\n    }\n  } else {\n    const splitPath = path.split(':');\n    /* Exactly one colon means that this is host:port. Zero colons means that\n     * there is no port. And multiple colons means that this is a bare IPv6\n     * address with no port */\n\n    if (splitPath.length === 2) {\n      if (NUMBER_REGEX.test(splitPath[1])) {\n        return {\n          host: splitPath[0],\n          port: +splitPath[1]\n        };\n      } else {\n        return null;\n      }\n    } else {\n      return {\n        host: path\n      };\n    }\n  }\n}\n\nexports.splitHostPort = splitHostPort;\n\nfunction uriToString(uri) {\n  let result = '';\n\n  if (uri.scheme !== undefined) {\n    result += uri.scheme + ':';\n  }\n\n  if (uri.authority !== undefined) {\n    result += '//' + uri.authority + '/';\n  }\n\n  result += uri.path;\n  return result;\n}\n\nexports.uriToString = uriToString;","map":{"version":3,"sources":["../../src/uri-parser.ts"],"names":[],"mappings":";AAAA;;;;;;;;;;;;;;;AAeG;;;;;;AAQH;;;;;AAKG;;AACH,MAAM,SAAS,GAAG,iDAAlB;;AAEA,SAAgB,QAAhB,CAAyB,SAAzB,EAA0C;AACxC,QAAM,SAAS,GAAG,SAAS,CAAC,IAAV,CAAe,SAAf,CAAlB;;AACA,MAAI,SAAS,KAAK,IAAlB,EAAwB;AACtB,WAAO,IAAP;AACD;;AACD,SAAO;AACL,IAAA,MAAM,EAAE,SAAS,CAAC,CAAD,CADZ;AAEL,IAAA,SAAS,EAAE,SAAS,CAAC,CAAD,CAFf;AAGL,IAAA,IAAI,EAAE,SAAS,CAAC,CAAD;AAHV,GAAP;AAKD;;AAVD,OAAA,CAAA,QAAA,GAAA,QAAA;AAiBA,MAAM,YAAY,GAAG,OAArB;;AAEA,SAAgB,aAAhB,CAA8B,IAA9B,EAA0C;AACxC,MAAI,IAAI,CAAC,UAAL,CAAgB,GAAhB,CAAJ,EAA0B;AACxB,UAAM,OAAO,GAAG,IAAI,CAAC,OAAL,CAAa,GAAb,CAAhB;;AACA,QAAI,OAAO,KAAK,CAAC,CAAjB,EAAoB;AAClB,aAAO,IAAP;AACD;;AACD,UAAM,IAAI,GAAG,IAAI,CAAC,SAAL,CAAe,CAAf,EAAkB,OAAlB,CAAb;AACA;AAC4C;;AAC5C,QAAI,IAAI,CAAC,OAAL,CAAa,GAAb,MAAsB,CAAC,CAA3B,EAA8B;AAC5B,aAAO,IAAP;AACD;;AACD,QAAI,IAAI,CAAC,MAAL,GAAc,OAAO,GAAG,CAA5B,EAA+B;AAC7B,UAAI,IAAI,CAAC,OAAO,GAAG,CAAX,CAAJ,KAAsB,GAA1B,EAA+B;AAC7B,cAAM,UAAU,GAAG,IAAI,CAAC,SAAL,CAAe,OAAO,GAAG,CAAzB,CAAnB;;AACA,YAAI,YAAY,CAAC,IAAb,CAAkB,UAAlB,CAAJ,EAAmC;AACjC,iBAAO;AACL,YAAA,IAAI,EAAE,IADD;AAEL,YAAA,IAAI,EAAE,CAAC;AAFF,WAAP;AAID,SALD,MAKO;AACL,iBAAO,IAAP;AACD;AACF,OAVD,MAUO;AACL,eAAO,IAAP;AACD;AACF,KAdD,MAcO;AACL,aAAO;AACL,QAAA;AADK,OAAP;AAGD;AACF,GA9BD,MA8BO;AACL,UAAM,SAAS,GAAG,IAAI,CAAC,KAAL,CAAW,GAAX,CAAlB;AACA;;AAE0B;;AAC1B,QAAI,SAAS,CAAC,MAAV,KAAqB,CAAzB,EAA4B;AAC1B,UAAI,YAAY,CAAC,IAAb,CAAkB,SAAS,CAAC,CAAD,CAA3B,CAAJ,EAAqC;AACnC,eAAO;AACL,UAAA,IAAI,EAAE,SAAS,CAAC,CAAD,CADV;AAEL,UAAA,IAAI,EAAE,CAAC,SAAS,CAAC,CAAD;AAFX,SAAP;AAID,OALD,MAKO;AACL,eAAO,IAAP;AACD;AACF,KATD,MASO;AACL,aAAO;AACL,QAAA,IAAI,EAAE;AADD,OAAP;AAGD;AACF;AACF;;AAnDD,OAAA,CAAA,aAAA,GAAA,aAAA;;AAqDA,SAAgB,WAAhB,CAA4B,GAA5B,EAAwC;AACtC,MAAI,MAAM,GAAG,EAAb;;AACA,MAAI,GAAG,CAAC,MAAJ,KAAe,SAAnB,EAA8B;AAC5B,IAAA,MAAM,IAAI,GAAG,CAAC,MAAJ,GAAa,GAAvB;AACD;;AACD,MAAI,GAAG,CAAC,SAAJ,KAAkB,SAAtB,EAAiC;AAC/B,IAAA,MAAM,IAAI,OAAO,GAAG,CAAC,SAAX,GAAuB,GAAjC;AACD;;AACD,EAAA,MAAM,IAAI,GAAG,CAAC,IAAd;AACA,SAAO,MAAP;AACD;;AAVD,OAAA,CAAA,WAAA,GAAA,WAAA","sourceRoot":"","sourcesContent":["\"use strict\";\n/*\n * Copyright 2020 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.uriToString = exports.splitHostPort = exports.parseUri = void 0;\n/*\n * The groups correspond to URI parts as follows:\n * 1. scheme\n * 2. authority\n * 3. path\n */\nconst URI_REGEX = /^(?:([A-Za-z0-9+.-]+):)?(?:\\/\\/([^/]*)\\/)?(.+)$/;\nfunction parseUri(uriString) {\n    const parsedUri = URI_REGEX.exec(uriString);\n    if (parsedUri === null) {\n        return null;\n    }\n    return {\n        scheme: parsedUri[1],\n        authority: parsedUri[2],\n        path: parsedUri[3],\n    };\n}\nexports.parseUri = parseUri;\nconst NUMBER_REGEX = /^\\d+$/;\nfunction splitHostPort(path) {\n    if (path.startsWith('[')) {\n        const hostEnd = path.indexOf(']');\n        if (hostEnd === -1) {\n            return null;\n        }\n        const host = path.substring(1, hostEnd);\n        /* Only an IPv6 address should be in bracketed notation, and an IPv6\n         * address should have at least one colon */\n        if (host.indexOf(':') === -1) {\n            return null;\n        }\n        if (path.length > hostEnd + 1) {\n            if (path[hostEnd + 1] === ':') {\n                const portString = path.substring(hostEnd + 2);\n                if (NUMBER_REGEX.test(portString)) {\n                    return {\n                        host: host,\n                        port: +portString,\n                    };\n                }\n                else {\n                    return null;\n                }\n            }\n            else {\n                return null;\n            }\n        }\n        else {\n            return {\n                host,\n            };\n        }\n    }\n    else {\n        const splitPath = path.split(':');\n        /* Exactly one colon means that this is host:port. Zero colons means that\n         * there is no port. And multiple colons means that this is a bare IPv6\n         * address with no port */\n        if (splitPath.length === 2) {\n            if (NUMBER_REGEX.test(splitPath[1])) {\n                return {\n                    host: splitPath[0],\n                    port: +splitPath[1],\n                };\n            }\n            else {\n                return null;\n            }\n        }\n        else {\n            return {\n                host: path,\n            };\n        }\n    }\n}\nexports.splitHostPort = splitHostPort;\nfunction uriToString(uri) {\n    let result = '';\n    if (uri.scheme !== undefined) {\n        result += uri.scheme + ':';\n    }\n    if (uri.authority !== undefined) {\n        result += '//' + uri.authority + '/';\n    }\n    result += uri.path;\n    return result;\n}\nexports.uriToString = uriToString;\n//# sourceMappingURL=uri-parser.js.map"]},"metadata":{},"sourceType":"script"}