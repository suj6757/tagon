{"ast":null,"code":"\"use strict\";\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Http2ServerCallStream = exports.ServerDuplexStreamImpl = exports.ServerWritableStreamImpl = exports.ServerReadableStreamImpl = exports.ServerUnaryCallImpl = void 0;\n\nconst events_1 = require(\"events\");\n\nconst http2 = require(\"http2\");\n\nconst stream_1 = require(\"stream\");\n\nconst constants_1 = require(\"./constants\");\n\nconst metadata_1 = require(\"./metadata\");\n\nconst stream_decoder_1 = require(\"./stream-decoder\");\n\nconst logging = require(\"./logging\");\n\nconst TRACER_NAME = 'server_call';\n\nfunction trace(text) {\n  logging.trace(constants_1.LogVerbosity.DEBUG, TRACER_NAME, text);\n}\n\nconst GRPC_ACCEPT_ENCODING_HEADER = 'grpc-accept-encoding';\nconst GRPC_ENCODING_HEADER = 'grpc-encoding';\nconst GRPC_MESSAGE_HEADER = 'grpc-message';\nconst GRPC_STATUS_HEADER = 'grpc-status';\nconst GRPC_TIMEOUT_HEADER = 'grpc-timeout';\nconst DEADLINE_REGEX = /(\\d{1,8})\\s*([HMSmun])/;\nconst deadlineUnitsToMs = {\n  H: 3600000,\n  M: 60000,\n  S: 1000,\n  m: 1,\n  u: 0.001,\n  n: 0.000001\n};\nconst defaultResponseHeaders = {\n  // TODO(cjihrig): Remove these encoding headers from the default response\n  // once compression is integrated.\n  [GRPC_ACCEPT_ENCODING_HEADER]: 'identity',\n  [GRPC_ENCODING_HEADER]: 'identity',\n  [http2.constants.HTTP2_HEADER_STATUS]: http2.constants.HTTP_STATUS_OK,\n  [http2.constants.HTTP2_HEADER_CONTENT_TYPE]: 'application/grpc+proto'\n};\nconst defaultResponseOptions = {\n  waitForTrailers: true\n};\n\nclass ServerUnaryCallImpl extends events_1.EventEmitter {\n  constructor(call, metadata, request) {\n    super();\n    this.call = call;\n    this.metadata = metadata;\n    this.request = request;\n    this.cancelled = false;\n    this.call.setupSurfaceCall(this);\n  }\n\n  getPeer() {\n    return this.call.getPeer();\n  }\n\n  sendMetadata(responseMetadata) {\n    this.call.sendMetadata(responseMetadata);\n  }\n\n  getDeadline() {\n    return this.call.getDeadline();\n  }\n\n}\n\nexports.ServerUnaryCallImpl = ServerUnaryCallImpl;\n\nclass ServerReadableStreamImpl extends stream_1.Readable {\n  constructor(call, metadata, deserialize) {\n    super({\n      objectMode: true\n    });\n    this.call = call;\n    this.metadata = metadata;\n    this.deserialize = deserialize;\n    this.cancelled = false;\n    this.call.setupSurfaceCall(this);\n    this.call.setupReadable(this);\n  }\n\n  _read(size) {\n    if (!this.call.consumeUnpushedMessages(this)) {\n      return;\n    }\n\n    this.call.resume();\n  }\n\n  getPeer() {\n    return this.call.getPeer();\n  }\n\n  sendMetadata(responseMetadata) {\n    this.call.sendMetadata(responseMetadata);\n  }\n\n  getDeadline() {\n    return this.call.getDeadline();\n  }\n\n}\n\nexports.ServerReadableStreamImpl = ServerReadableStreamImpl;\n\nclass ServerWritableStreamImpl extends stream_1.Writable {\n  constructor(call, metadata, serialize, request) {\n    super({\n      objectMode: true\n    });\n    this.call = call;\n    this.metadata = metadata;\n    this.serialize = serialize;\n    this.request = request;\n    this.cancelled = false;\n    this.trailingMetadata = new metadata_1.Metadata();\n    this.call.setupSurfaceCall(this);\n    this.on('error', err => {\n      this.call.sendError(err);\n      this.end();\n    });\n  }\n\n  getPeer() {\n    return this.call.getPeer();\n  }\n\n  sendMetadata(responseMetadata) {\n    this.call.sendMetadata(responseMetadata);\n  }\n\n  getDeadline() {\n    return this.call.getDeadline();\n  }\n\n  _write(chunk, encoding, // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  callback) {\n    try {\n      const response = this.call.serializeMessage(chunk);\n\n      if (!this.call.write(response)) {\n        this.call.once('drain', callback);\n        return;\n      }\n    } catch (err) {\n      err.code = constants_1.Status.INTERNAL;\n      this.emit('error', err);\n    }\n\n    callback();\n  }\n\n  _final(callback) {\n    this.call.sendStatus({\n      code: constants_1.Status.OK,\n      details: 'OK',\n      metadata: this.trailingMetadata\n    });\n    callback(null);\n  } // eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n\n  end(metadata) {\n    if (metadata) {\n      this.trailingMetadata = metadata;\n    }\n\n    super.end();\n  }\n\n}\n\nexports.ServerWritableStreamImpl = ServerWritableStreamImpl;\n\nclass ServerDuplexStreamImpl extends stream_1.Duplex {\n  constructor(call, metadata, serialize, deserialize) {\n    super({\n      objectMode: true\n    });\n    this.call = call;\n    this.metadata = metadata;\n    this.serialize = serialize;\n    this.deserialize = deserialize;\n    this.cancelled = false;\n    this.trailingMetadata = new metadata_1.Metadata();\n    this.call.setupSurfaceCall(this);\n    this.call.setupReadable(this);\n    this.on('error', err => {\n      this.call.sendError(err);\n      this.end();\n    });\n  }\n\n  getPeer() {\n    return this.call.getPeer();\n  }\n\n  sendMetadata(responseMetadata) {\n    this.call.sendMetadata(responseMetadata);\n  }\n\n  getDeadline() {\n    return this.call.getDeadline();\n  } // eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n\n  end(metadata) {\n    if (metadata) {\n      this.trailingMetadata = metadata;\n    }\n\n    super.end();\n  }\n\n}\n\nexports.ServerDuplexStreamImpl = ServerDuplexStreamImpl;\nServerDuplexStreamImpl.prototype._read = ServerReadableStreamImpl.prototype._read;\nServerDuplexStreamImpl.prototype._write = ServerWritableStreamImpl.prototype._write;\nServerDuplexStreamImpl.prototype._final = ServerWritableStreamImpl.prototype._final;\nServerDuplexStreamImpl.prototype.end = ServerWritableStreamImpl.prototype.end; // Internal class that wraps the HTTP2 request.\n\nclass Http2ServerCallStream extends events_1.EventEmitter {\n  constructor(stream, handler, options) {\n    super();\n    this.stream = stream;\n    this.handler = handler;\n    this.options = options;\n    this.cancelled = false;\n    this.deadlineTimer = setTimeout(() => {}, 0);\n    this.deadline = Infinity;\n    this.wantTrailers = false;\n    this.metadataSent = false;\n    this.canPush = false;\n    this.isPushPending = false;\n    this.bufferedMessages = [];\n    this.messagesToPush = [];\n    this.maxSendMessageSize = constants_1.DEFAULT_MAX_SEND_MESSAGE_LENGTH;\n    this.maxReceiveMessageSize = constants_1.DEFAULT_MAX_RECEIVE_MESSAGE_LENGTH;\n    this.stream.once('error', err => {\n      /* We need an error handler to avoid uncaught error event exceptions, but\n       * there is nothing we can reasonably do here. Any error event should\n       * have a corresponding close event, which handles emitting the cancelled\n       * event. And the stream is now in a bad state, so we can't reasonably\n       * expect to be able to send an error over it. */\n    });\n    this.stream.once('close', () => {\n      var _a;\n\n      trace('Request to method ' + ((_a = this.handler) === null || _a === void 0 ? void 0 : _a.path) + ' stream closed with rstCode ' + this.stream.rstCode);\n      this.cancelled = true;\n      this.emit('cancelled', 'cancelled');\n    });\n    this.stream.on('drain', () => {\n      this.emit('drain');\n    });\n\n    if ('grpc.max_send_message_length' in options) {\n      this.maxSendMessageSize = options['grpc.max_send_message_length'];\n    }\n\n    if ('grpc.max_receive_message_length' in options) {\n      this.maxReceiveMessageSize = options['grpc.max_receive_message_length'];\n    } // Clear noop timer\n\n\n    clearTimeout(this.deadlineTimer);\n  }\n\n  checkCancelled() {\n    /* In some cases the stream can become destroyed before the close event\n     * fires. That creates a race condition that this check works around */\n    if (this.stream.destroyed) {\n      this.cancelled = true;\n    }\n\n    return this.cancelled;\n  }\n\n  sendMetadata(customMetadata) {\n    if (this.checkCancelled()) {\n      return;\n    }\n\n    if (this.metadataSent) {\n      return;\n    }\n\n    this.metadataSent = true;\n    const custom = customMetadata ? customMetadata.toHttp2Headers() : null; // TODO(cjihrig): Include compression headers.\n\n    const headers = Object.assign({}, defaultResponseHeaders, custom);\n    this.stream.respond(headers, defaultResponseOptions);\n  }\n\n  receiveMetadata(headers) {\n    const metadata = metadata_1.Metadata.fromHttp2Headers(headers); // TODO(cjihrig): Receive compression metadata.\n\n    const timeoutHeader = metadata.get(GRPC_TIMEOUT_HEADER);\n\n    if (timeoutHeader.length > 0) {\n      const match = timeoutHeader[0].toString().match(DEADLINE_REGEX);\n\n      if (match === null) {\n        const err = new Error('Invalid deadline');\n        err.code = constants_1.Status.OUT_OF_RANGE;\n        this.sendError(err);\n        return;\n      }\n\n      const timeout = +match[1] * deadlineUnitsToMs[match[2]] | 0;\n      const now = new Date();\n      this.deadline = now.setMilliseconds(now.getMilliseconds() + timeout);\n      this.deadlineTimer = setTimeout(handleExpiredDeadline, timeout, this);\n      metadata.remove(GRPC_TIMEOUT_HEADER);\n    } // Remove several headers that should not be propagated to the application\n\n\n    metadata.remove(http2.constants.HTTP2_HEADER_ACCEPT_ENCODING);\n    metadata.remove(http2.constants.HTTP2_HEADER_TE);\n    metadata.remove(http2.constants.HTTP2_HEADER_CONTENT_TYPE);\n    metadata.remove('grpc-encoding');\n    metadata.remove('grpc-accept-encoding');\n    return metadata;\n  }\n\n  receiveUnaryMessage() {\n    return new Promise((resolve, reject) => {\n      const stream = this.stream;\n      const chunks = [];\n      let totalLength = 0;\n      stream.on('data', data => {\n        chunks.push(data);\n        totalLength += data.byteLength;\n      });\n      stream.once('end', async () => {\n        try {\n          const requestBytes = Buffer.concat(chunks, totalLength);\n\n          if (this.maxReceiveMessageSize !== -1 && requestBytes.length > this.maxReceiveMessageSize) {\n            this.sendError({\n              code: constants_1.Status.RESOURCE_EXHAUSTED,\n              details: `Received message larger than max (${requestBytes.length} vs. ${this.maxReceiveMessageSize})`\n            });\n            resolve();\n          }\n\n          resolve(this.deserializeMessage(requestBytes));\n        } catch (err) {\n          err.code = constants_1.Status.INTERNAL;\n          this.sendError(err);\n          resolve();\n        }\n      });\n    });\n  }\n\n  serializeMessage(value) {\n    const messageBuffer = this.handler.serialize(value); // TODO(cjihrig): Call compression aware serializeMessage().\n\n    const byteLength = messageBuffer.byteLength;\n    const output = Buffer.allocUnsafe(byteLength + 5);\n    output.writeUInt8(0, 0);\n    output.writeUInt32BE(byteLength, 1);\n    messageBuffer.copy(output, 5);\n    return output;\n  }\n\n  deserializeMessage(bytes) {\n    // TODO(cjihrig): Call compression aware deserializeMessage().\n    const receivedMessage = bytes.slice(5);\n    return this.handler.deserialize(receivedMessage);\n  }\n\n  async sendUnaryMessage(err, value, metadata, flags) {\n    if (this.checkCancelled()) {\n      return;\n    }\n\n    if (!metadata) {\n      metadata = new metadata_1.Metadata();\n    }\n\n    if (err) {\n      if (!Object.prototype.hasOwnProperty.call(err, 'metadata')) {\n        err.metadata = metadata;\n      }\n\n      this.sendError(err);\n      return;\n    }\n\n    try {\n      const response = this.serializeMessage(value);\n      this.write(response);\n      this.sendStatus({\n        code: constants_1.Status.OK,\n        details: 'OK',\n        metadata\n      });\n    } catch (err) {\n      err.code = constants_1.Status.INTERNAL;\n      this.sendError(err);\n    }\n  }\n\n  sendStatus(statusObj) {\n    var _a;\n\n    if (this.checkCancelled()) {\n      return;\n    }\n\n    trace('Request to method ' + ((_a = this.handler) === null || _a === void 0 ? void 0 : _a.path) + ' ended with status code: ' + constants_1.Status[statusObj.code] + ' details: ' + statusObj.details);\n    clearTimeout(this.deadlineTimer);\n\n    if (!this.wantTrailers) {\n      this.wantTrailers = true;\n      this.stream.once('wantTrailers', () => {\n        const trailersToSend = Object.assign({\n          [GRPC_STATUS_HEADER]: statusObj.code,\n          [GRPC_MESSAGE_HEADER]: encodeURI(statusObj.details)\n        }, statusObj.metadata.toHttp2Headers());\n        this.stream.sendTrailers(trailersToSend);\n      });\n      this.sendMetadata();\n      this.stream.end();\n    }\n  }\n\n  sendError(error) {\n    if (this.checkCancelled()) {\n      return;\n    }\n\n    const status = {\n      code: constants_1.Status.UNKNOWN,\n      details: 'message' in error ? error.message : 'Unknown Error',\n      metadata: 'metadata' in error && error.metadata !== undefined ? error.metadata : new metadata_1.Metadata()\n    };\n\n    if ('code' in error && typeof error.code === 'number' && Number.isInteger(error.code)) {\n      status.code = error.code;\n\n      if ('details' in error && typeof error.details === 'string') {\n        status.details = error.details;\n      }\n    }\n\n    this.sendStatus(status);\n  }\n\n  write(chunk) {\n    if (this.checkCancelled()) {\n      return;\n    }\n\n    if (this.maxSendMessageSize !== -1 && chunk.length > this.maxSendMessageSize) {\n      this.sendError({\n        code: constants_1.Status.RESOURCE_EXHAUSTED,\n        details: `Sent message larger than max (${chunk.length} vs. ${this.maxSendMessageSize})`\n      });\n      return;\n    }\n\n    this.sendMetadata();\n    return this.stream.write(chunk);\n  }\n\n  resume() {\n    this.stream.resume();\n  }\n\n  setupSurfaceCall(call) {\n    this.once('cancelled', reason => {\n      call.cancelled = true;\n      call.emit('cancelled', reason);\n    });\n  }\n\n  setupReadable(readable) {\n    const decoder = new stream_decoder_1.StreamDecoder();\n    this.stream.on('data', async data => {\n      const messages = decoder.write(data);\n\n      for (const message of messages) {\n        if (this.maxReceiveMessageSize !== -1 && message.length > this.maxReceiveMessageSize) {\n          this.sendError({\n            code: constants_1.Status.RESOURCE_EXHAUSTED,\n            details: `Received message larger than max (${message.length} vs. ${this.maxReceiveMessageSize})`\n          });\n          return;\n        }\n\n        this.pushOrBufferMessage(readable, message);\n      }\n    });\n    this.stream.once('end', () => {\n      this.pushOrBufferMessage(readable, null);\n    });\n  }\n\n  consumeUnpushedMessages(readable) {\n    this.canPush = true;\n\n    while (this.messagesToPush.length > 0) {\n      const nextMessage = this.messagesToPush.shift();\n      const canPush = readable.push(nextMessage);\n\n      if (nextMessage === null || canPush === false) {\n        this.canPush = false;\n        break;\n      }\n    }\n\n    return this.canPush;\n  }\n\n  pushOrBufferMessage(readable, messageBytes) {\n    if (this.isPushPending) {\n      this.bufferedMessages.push(messageBytes);\n    } else {\n      this.pushMessage(readable, messageBytes);\n    }\n  }\n\n  async pushMessage(readable, messageBytes) {\n    if (messageBytes === null) {\n      if (this.canPush) {\n        readable.push(null);\n      } else {\n        this.messagesToPush.push(null);\n      }\n\n      return;\n    }\n\n    this.isPushPending = true;\n\n    try {\n      const deserialized = await this.deserializeMessage(messageBytes);\n\n      if (this.canPush) {\n        if (!readable.push(deserialized)) {\n          this.canPush = false;\n          this.stream.pause();\n        }\n      } else {\n        this.messagesToPush.push(deserialized);\n      }\n    } catch (error) {\n      // Ignore any remaining messages when errors occur.\n      this.bufferedMessages.length = 0;\n\n      if (!('code' in error && typeof error.code === 'number' && Number.isInteger(error.code) && error.code >= constants_1.Status.OK && error.code <= constants_1.Status.UNAUTHENTICATED)) {\n        // The error code is not a valid gRPC code so its being overwritten.\n        error.code = constants_1.Status.INTERNAL;\n      }\n\n      readable.emit('error', error);\n    }\n\n    this.isPushPending = false;\n\n    if (this.bufferedMessages.length > 0) {\n      this.pushMessage(readable, this.bufferedMessages.shift());\n    }\n  }\n\n  getPeer() {\n    const socket = this.stream.session.socket;\n\n    if (socket.remoteAddress) {\n      if (socket.remotePort) {\n        return `${socket.remoteAddress}:${socket.remotePort}`;\n      } else {\n        return socket.remoteAddress;\n      }\n    } else {\n      return 'unknown';\n    }\n  }\n\n  getDeadline() {\n    return this.deadline;\n  }\n\n}\n\nexports.Http2ServerCallStream = Http2ServerCallStream;\n\nfunction handleExpiredDeadline(call) {\n  const err = new Error('Deadline exceeded');\n  err.code = constants_1.Status.DEADLINE_EXCEEDED;\n  call.sendError(err);\n  call.cancelled = true;\n  call.emit('cancelled', 'deadline');\n}","map":{"version":3,"sources":["../../src/server-call.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Http2ServerCallStream = exports.ServerDuplexStreamImpl = exports.ServerWritableStreamImpl = exports.ServerReadableStreamImpl = exports.ServerUnaryCallImpl = void 0;\nconst events_1 = require(\"events\");\nconst http2 = require(\"http2\");\nconst stream_1 = require(\"stream\");\nconst constants_1 = require(\"./constants\");\nconst metadata_1 = require(\"./metadata\");\nconst stream_decoder_1 = require(\"./stream-decoder\");\nconst logging = require(\"./logging\");\nconst TRACER_NAME = 'server_call';\nfunction trace(text) {\n    logging.trace(constants_1.LogVerbosity.DEBUG, TRACER_NAME, text);\n}\nconst GRPC_ACCEPT_ENCODING_HEADER = 'grpc-accept-encoding';\nconst GRPC_ENCODING_HEADER = 'grpc-encoding';\nconst GRPC_MESSAGE_HEADER = 'grpc-message';\nconst GRPC_STATUS_HEADER = 'grpc-status';\nconst GRPC_TIMEOUT_HEADER = 'grpc-timeout';\nconst DEADLINE_REGEX = /(\\d{1,8})\\s*([HMSmun])/;\nconst deadlineUnitsToMs = {\n    H: 3600000,\n    M: 60000,\n    S: 1000,\n    m: 1,\n    u: 0.001,\n    n: 0.000001,\n};\nconst defaultResponseHeaders = {\n    // TODO(cjihrig): Remove these encoding headers from the default response\n    // once compression is integrated.\n    [GRPC_ACCEPT_ENCODING_HEADER]: 'identity',\n    [GRPC_ENCODING_HEADER]: 'identity',\n    [http2.constants.HTTP2_HEADER_STATUS]: http2.constants.HTTP_STATUS_OK,\n    [http2.constants.HTTP2_HEADER_CONTENT_TYPE]: 'application/grpc+proto',\n};\nconst defaultResponseOptions = {\n    waitForTrailers: true,\n};\nclass ServerUnaryCallImpl extends events_1.EventEmitter {\n    constructor(call, metadata, request) {\n        super();\n        this.call = call;\n        this.metadata = metadata;\n        this.request = request;\n        this.cancelled = false;\n        this.call.setupSurfaceCall(this);\n    }\n    getPeer() {\n        return this.call.getPeer();\n    }\n    sendMetadata(responseMetadata) {\n        this.call.sendMetadata(responseMetadata);\n    }\n    getDeadline() {\n        return this.call.getDeadline();\n    }\n}\nexports.ServerUnaryCallImpl = ServerUnaryCallImpl;\nclass ServerReadableStreamImpl extends stream_1.Readable {\n    constructor(call, metadata, deserialize) {\n        super({ objectMode: true });\n        this.call = call;\n        this.metadata = metadata;\n        this.deserialize = deserialize;\n        this.cancelled = false;\n        this.call.setupSurfaceCall(this);\n        this.call.setupReadable(this);\n    }\n    _read(size) {\n        if (!this.call.consumeUnpushedMessages(this)) {\n            return;\n        }\n        this.call.resume();\n    }\n    getPeer() {\n        return this.call.getPeer();\n    }\n    sendMetadata(responseMetadata) {\n        this.call.sendMetadata(responseMetadata);\n    }\n    getDeadline() {\n        return this.call.getDeadline();\n    }\n}\nexports.ServerReadableStreamImpl = ServerReadableStreamImpl;\nclass ServerWritableStreamImpl extends stream_1.Writable {\n    constructor(call, metadata, serialize, request) {\n        super({ objectMode: true });\n        this.call = call;\n        this.metadata = metadata;\n        this.serialize = serialize;\n        this.request = request;\n        this.cancelled = false;\n        this.trailingMetadata = new metadata_1.Metadata();\n        this.call.setupSurfaceCall(this);\n        this.on('error', (err) => {\n            this.call.sendError(err);\n            this.end();\n        });\n    }\n    getPeer() {\n        return this.call.getPeer();\n    }\n    sendMetadata(responseMetadata) {\n        this.call.sendMetadata(responseMetadata);\n    }\n    getDeadline() {\n        return this.call.getDeadline();\n    }\n    _write(chunk, encoding, \n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    callback) {\n        try {\n            const response = this.call.serializeMessage(chunk);\n            if (!this.call.write(response)) {\n                this.call.once('drain', callback);\n                return;\n            }\n        }\n        catch (err) {\n            err.code = constants_1.Status.INTERNAL;\n            this.emit('error', err);\n        }\n        callback();\n    }\n    _final(callback) {\n        this.call.sendStatus({\n            code: constants_1.Status.OK,\n            details: 'OK',\n            metadata: this.trailingMetadata,\n        });\n        callback(null);\n    }\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    end(metadata) {\n        if (metadata) {\n            this.trailingMetadata = metadata;\n        }\n        super.end();\n    }\n}\nexports.ServerWritableStreamImpl = ServerWritableStreamImpl;\nclass ServerDuplexStreamImpl extends stream_1.Duplex {\n    constructor(call, metadata, serialize, deserialize) {\n        super({ objectMode: true });\n        this.call = call;\n        this.metadata = metadata;\n        this.serialize = serialize;\n        this.deserialize = deserialize;\n        this.cancelled = false;\n        this.trailingMetadata = new metadata_1.Metadata();\n        this.call.setupSurfaceCall(this);\n        this.call.setupReadable(this);\n        this.on('error', (err) => {\n            this.call.sendError(err);\n            this.end();\n        });\n    }\n    getPeer() {\n        return this.call.getPeer();\n    }\n    sendMetadata(responseMetadata) {\n        this.call.sendMetadata(responseMetadata);\n    }\n    getDeadline() {\n        return this.call.getDeadline();\n    }\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    end(metadata) {\n        if (metadata) {\n            this.trailingMetadata = metadata;\n        }\n        super.end();\n    }\n}\nexports.ServerDuplexStreamImpl = ServerDuplexStreamImpl;\nServerDuplexStreamImpl.prototype._read =\n    ServerReadableStreamImpl.prototype._read;\nServerDuplexStreamImpl.prototype._write =\n    ServerWritableStreamImpl.prototype._write;\nServerDuplexStreamImpl.prototype._final =\n    ServerWritableStreamImpl.prototype._final;\nServerDuplexStreamImpl.prototype.end = ServerWritableStreamImpl.prototype.end;\n// Internal class that wraps the HTTP2 request.\nclass Http2ServerCallStream extends events_1.EventEmitter {\n    constructor(stream, handler, options) {\n        super();\n        this.stream = stream;\n        this.handler = handler;\n        this.options = options;\n        this.cancelled = false;\n        this.deadlineTimer = setTimeout(() => { }, 0);\n        this.deadline = Infinity;\n        this.wantTrailers = false;\n        this.metadataSent = false;\n        this.canPush = false;\n        this.isPushPending = false;\n        this.bufferedMessages = [];\n        this.messagesToPush = [];\n        this.maxSendMessageSize = constants_1.DEFAULT_MAX_SEND_MESSAGE_LENGTH;\n        this.maxReceiveMessageSize = constants_1.DEFAULT_MAX_RECEIVE_MESSAGE_LENGTH;\n        this.stream.once('error', (err) => {\n            /* We need an error handler to avoid uncaught error event exceptions, but\n             * there is nothing we can reasonably do here. Any error event should\n             * have a corresponding close event, which handles emitting the cancelled\n             * event. And the stream is now in a bad state, so we can't reasonably\n             * expect to be able to send an error over it. */\n        });\n        this.stream.once('close', () => {\n            var _a;\n            trace('Request to method ' + ((_a = this.handler) === null || _a === void 0 ? void 0 : _a.path) +\n                ' stream closed with rstCode ' +\n                this.stream.rstCode);\n            this.cancelled = true;\n            this.emit('cancelled', 'cancelled');\n        });\n        this.stream.on('drain', () => {\n            this.emit('drain');\n        });\n        if ('grpc.max_send_message_length' in options) {\n            this.maxSendMessageSize = options['grpc.max_send_message_length'];\n        }\n        if ('grpc.max_receive_message_length' in options) {\n            this.maxReceiveMessageSize = options['grpc.max_receive_message_length'];\n        }\n        // Clear noop timer\n        clearTimeout(this.deadlineTimer);\n    }\n    checkCancelled() {\n        /* In some cases the stream can become destroyed before the close event\n         * fires. That creates a race condition that this check works around */\n        if (this.stream.destroyed) {\n            this.cancelled = true;\n        }\n        return this.cancelled;\n    }\n    sendMetadata(customMetadata) {\n        if (this.checkCancelled()) {\n            return;\n        }\n        if (this.metadataSent) {\n            return;\n        }\n        this.metadataSent = true;\n        const custom = customMetadata ? customMetadata.toHttp2Headers() : null;\n        // TODO(cjihrig): Include compression headers.\n        const headers = Object.assign({}, defaultResponseHeaders, custom);\n        this.stream.respond(headers, defaultResponseOptions);\n    }\n    receiveMetadata(headers) {\n        const metadata = metadata_1.Metadata.fromHttp2Headers(headers);\n        // TODO(cjihrig): Receive compression metadata.\n        const timeoutHeader = metadata.get(GRPC_TIMEOUT_HEADER);\n        if (timeoutHeader.length > 0) {\n            const match = timeoutHeader[0].toString().match(DEADLINE_REGEX);\n            if (match === null) {\n                const err = new Error('Invalid deadline');\n                err.code = constants_1.Status.OUT_OF_RANGE;\n                this.sendError(err);\n                return;\n            }\n            const timeout = (+match[1] * deadlineUnitsToMs[match[2]]) | 0;\n            const now = new Date();\n            this.deadline = now.setMilliseconds(now.getMilliseconds() + timeout);\n            this.deadlineTimer = setTimeout(handleExpiredDeadline, timeout, this);\n            metadata.remove(GRPC_TIMEOUT_HEADER);\n        }\n        // Remove several headers that should not be propagated to the application\n        metadata.remove(http2.constants.HTTP2_HEADER_ACCEPT_ENCODING);\n        metadata.remove(http2.constants.HTTP2_HEADER_TE);\n        metadata.remove(http2.constants.HTTP2_HEADER_CONTENT_TYPE);\n        metadata.remove('grpc-encoding');\n        metadata.remove('grpc-accept-encoding');\n        return metadata;\n    }\n    receiveUnaryMessage() {\n        return new Promise((resolve, reject) => {\n            const stream = this.stream;\n            const chunks = [];\n            let totalLength = 0;\n            stream.on('data', (data) => {\n                chunks.push(data);\n                totalLength += data.byteLength;\n            });\n            stream.once('end', async () => {\n                try {\n                    const requestBytes = Buffer.concat(chunks, totalLength);\n                    if (this.maxReceiveMessageSize !== -1 &&\n                        requestBytes.length > this.maxReceiveMessageSize) {\n                        this.sendError({\n                            code: constants_1.Status.RESOURCE_EXHAUSTED,\n                            details: `Received message larger than max (${requestBytes.length} vs. ${this.maxReceiveMessageSize})`,\n                        });\n                        resolve();\n                    }\n                    resolve(this.deserializeMessage(requestBytes));\n                }\n                catch (err) {\n                    err.code = constants_1.Status.INTERNAL;\n                    this.sendError(err);\n                    resolve();\n                }\n            });\n        });\n    }\n    serializeMessage(value) {\n        const messageBuffer = this.handler.serialize(value);\n        // TODO(cjihrig): Call compression aware serializeMessage().\n        const byteLength = messageBuffer.byteLength;\n        const output = Buffer.allocUnsafe(byteLength + 5);\n        output.writeUInt8(0, 0);\n        output.writeUInt32BE(byteLength, 1);\n        messageBuffer.copy(output, 5);\n        return output;\n    }\n    deserializeMessage(bytes) {\n        // TODO(cjihrig): Call compression aware deserializeMessage().\n        const receivedMessage = bytes.slice(5);\n        return this.handler.deserialize(receivedMessage);\n    }\n    async sendUnaryMessage(err, value, metadata, flags) {\n        if (this.checkCancelled()) {\n            return;\n        }\n        if (!metadata) {\n            metadata = new metadata_1.Metadata();\n        }\n        if (err) {\n            if (!Object.prototype.hasOwnProperty.call(err, 'metadata')) {\n                err.metadata = metadata;\n            }\n            this.sendError(err);\n            return;\n        }\n        try {\n            const response = this.serializeMessage(value);\n            this.write(response);\n            this.sendStatus({ code: constants_1.Status.OK, details: 'OK', metadata });\n        }\n        catch (err) {\n            err.code = constants_1.Status.INTERNAL;\n            this.sendError(err);\n        }\n    }\n    sendStatus(statusObj) {\n        var _a;\n        if (this.checkCancelled()) {\n            return;\n        }\n        trace('Request to method ' + ((_a = this.handler) === null || _a === void 0 ? void 0 : _a.path) +\n            ' ended with status code: ' +\n            constants_1.Status[statusObj.code] +\n            ' details: ' +\n            statusObj.details);\n        clearTimeout(this.deadlineTimer);\n        if (!this.wantTrailers) {\n            this.wantTrailers = true;\n            this.stream.once('wantTrailers', () => {\n                const trailersToSend = Object.assign({\n                    [GRPC_STATUS_HEADER]: statusObj.code,\n                    [GRPC_MESSAGE_HEADER]: encodeURI(statusObj.details),\n                }, statusObj.metadata.toHttp2Headers());\n                this.stream.sendTrailers(trailersToSend);\n            });\n            this.sendMetadata();\n            this.stream.end();\n        }\n    }\n    sendError(error) {\n        if (this.checkCancelled()) {\n            return;\n        }\n        const status = {\n            code: constants_1.Status.UNKNOWN,\n            details: 'message' in error ? error.message : 'Unknown Error',\n            metadata: 'metadata' in error && error.metadata !== undefined\n                ? error.metadata\n                : new metadata_1.Metadata(),\n        };\n        if ('code' in error &&\n            typeof error.code === 'number' &&\n            Number.isInteger(error.code)) {\n            status.code = error.code;\n            if ('details' in error && typeof error.details === 'string') {\n                status.details = error.details;\n            }\n        }\n        this.sendStatus(status);\n    }\n    write(chunk) {\n        if (this.checkCancelled()) {\n            return;\n        }\n        if (this.maxSendMessageSize !== -1 &&\n            chunk.length > this.maxSendMessageSize) {\n            this.sendError({\n                code: constants_1.Status.RESOURCE_EXHAUSTED,\n                details: `Sent message larger than max (${chunk.length} vs. ${this.maxSendMessageSize})`,\n            });\n            return;\n        }\n        this.sendMetadata();\n        return this.stream.write(chunk);\n    }\n    resume() {\n        this.stream.resume();\n    }\n    setupSurfaceCall(call) {\n        this.once('cancelled', (reason) => {\n            call.cancelled = true;\n            call.emit('cancelled', reason);\n        });\n    }\n    setupReadable(readable) {\n        const decoder = new stream_decoder_1.StreamDecoder();\n        this.stream.on('data', async (data) => {\n            const messages = decoder.write(data);\n            for (const message of messages) {\n                if (this.maxReceiveMessageSize !== -1 &&\n                    message.length > this.maxReceiveMessageSize) {\n                    this.sendError({\n                        code: constants_1.Status.RESOURCE_EXHAUSTED,\n                        details: `Received message larger than max (${message.length} vs. ${this.maxReceiveMessageSize})`,\n                    });\n                    return;\n                }\n                this.pushOrBufferMessage(readable, message);\n            }\n        });\n        this.stream.once('end', () => {\n            this.pushOrBufferMessage(readable, null);\n        });\n    }\n    consumeUnpushedMessages(readable) {\n        this.canPush = true;\n        while (this.messagesToPush.length > 0) {\n            const nextMessage = this.messagesToPush.shift();\n            const canPush = readable.push(nextMessage);\n            if (nextMessage === null || canPush === false) {\n                this.canPush = false;\n                break;\n            }\n        }\n        return this.canPush;\n    }\n    pushOrBufferMessage(readable, messageBytes) {\n        if (this.isPushPending) {\n            this.bufferedMessages.push(messageBytes);\n        }\n        else {\n            this.pushMessage(readable, messageBytes);\n        }\n    }\n    async pushMessage(readable, messageBytes) {\n        if (messageBytes === null) {\n            if (this.canPush) {\n                readable.push(null);\n            }\n            else {\n                this.messagesToPush.push(null);\n            }\n            return;\n        }\n        this.isPushPending = true;\n        try {\n            const deserialized = await this.deserializeMessage(messageBytes);\n            if (this.canPush) {\n                if (!readable.push(deserialized)) {\n                    this.canPush = false;\n                    this.stream.pause();\n                }\n            }\n            else {\n                this.messagesToPush.push(deserialized);\n            }\n        }\n        catch (error) {\n            // Ignore any remaining messages when errors occur.\n            this.bufferedMessages.length = 0;\n            if (!('code' in error &&\n                typeof error.code === 'number' &&\n                Number.isInteger(error.code) &&\n                error.code >= constants_1.Status.OK &&\n                error.code <= constants_1.Status.UNAUTHENTICATED)) {\n                // The error code is not a valid gRPC code so its being overwritten.\n                error.code = constants_1.Status.INTERNAL;\n            }\n            readable.emit('error', error);\n        }\n        this.isPushPending = false;\n        if (this.bufferedMessages.length > 0) {\n            this.pushMessage(readable, this.bufferedMessages.shift());\n        }\n    }\n    getPeer() {\n        const socket = this.stream.session.socket;\n        if (socket.remoteAddress) {\n            if (socket.remotePort) {\n                return `${socket.remoteAddress}:${socket.remotePort}`;\n            }\n            else {\n                return socket.remoteAddress;\n            }\n        }\n        else {\n            return 'unknown';\n        }\n    }\n    getDeadline() {\n        return this.deadline;\n    }\n}\nexports.Http2ServerCallStream = Http2ServerCallStream;\nfunction handleExpiredDeadline(call) {\n    const err = new Error('Deadline exceeded');\n    err.code = constants_1.Status.DEADLINE_EXCEEDED;\n    call.sendError(err);\n    call.cancelled = true;\n    call.emit('cancelled', 'deadline');\n}\n//# sourceMappingURL=server-call.js.map"]},"metadata":{},"sourceType":"script"}