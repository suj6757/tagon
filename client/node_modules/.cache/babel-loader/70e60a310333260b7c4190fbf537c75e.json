{"ast":null,"code":"\"use strict\";\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.setup = void 0;\n\nconst resolver_1 = require(\"./resolver\");\n\nconst dns = require(\"dns\");\n\nconst util = require(\"util\");\n\nconst service_config_1 = require(\"./service-config\");\n\nconst constants_1 = require(\"./constants\");\n\nconst metadata_1 = require(\"./metadata\");\n\nconst logging = require(\"./logging\");\n\nconst constants_2 = require(\"./constants\");\n\nconst uri_parser_1 = require(\"./uri-parser\");\n\nconst net_1 = require(\"net\");\n\nconst TRACER_NAME = 'dns_resolver';\n\nfunction trace(text) {\n  logging.trace(constants_2.LogVerbosity.DEBUG, TRACER_NAME, text);\n}\n/**\n * The default TCP port to connect to if not explicitly specified in the target.\n */\n\n\nconst DEFAULT_PORT = 443;\nconst resolveTxtPromise = util.promisify(dns.resolveTxt);\nconst dnsLookupPromise = util.promisify(dns.lookup);\n/**\n * Merge any number of arrays into a single alternating array\n * @param arrays\n */\n\nfunction mergeArrays(...arrays) {\n  const result = [];\n\n  for (let i = 0; i < Math.max.apply(null, arrays.map(array => array.length)); i++) {\n    for (const array of arrays) {\n      if (i < array.length) {\n        result.push(array[i]);\n      }\n    }\n  }\n\n  return result;\n}\n/**\n * Resolver implementation that handles DNS names and IP addresses.\n */\n\n\nclass DnsResolver {\n  constructor(target, listener, channelOptions) {\n    var _a, _b;\n\n    this.target = target;\n    this.listener = listener;\n    this.pendingLookupPromise = null;\n    this.pendingTxtPromise = null;\n    this.latestLookupResult = null;\n    this.latestServiceConfig = null;\n    this.latestServiceConfigError = null;\n    trace('Resolver constructed for target ' + uri_parser_1.uriToString(target));\n    const hostPort = uri_parser_1.splitHostPort(target.path);\n\n    if (hostPort === null) {\n      this.ipResult = null;\n      this.dnsHostname = null;\n      this.port = null;\n    } else {\n      if (net_1.isIPv4(hostPort.host) || net_1.isIPv6(hostPort.host)) {\n        this.ipResult = [{\n          host: hostPort.host,\n          port: (_a = hostPort.port) !== null && _a !== void 0 ? _a : DEFAULT_PORT\n        }];\n        this.dnsHostname = null;\n        this.port = null;\n      } else {\n        this.ipResult = null;\n        this.dnsHostname = hostPort.host;\n        this.port = (_b = hostPort.port) !== null && _b !== void 0 ? _b : DEFAULT_PORT;\n      }\n    }\n\n    this.percentage = Math.random() * 100;\n    this.defaultResolutionError = {\n      code: constants_1.Status.UNAVAILABLE,\n      details: `Name resolution failed for target ${uri_parser_1.uriToString(this.target)}`,\n      metadata: new metadata_1.Metadata()\n    };\n  }\n  /**\n   * If the target is an IP address, just provide that address as a result.\n   * Otherwise, initiate A, AAAA, and TXT lookups\n   */\n\n\n  startResolution() {\n    if (this.ipResult !== null) {\n      trace('Returning IP address for target ' + uri_parser_1.uriToString(this.target));\n      setImmediate(() => {\n        this.listener.onSuccessfulResolution(this.ipResult, null, null, null, {});\n      });\n      return;\n    }\n\n    if (this.dnsHostname === null) {\n      setImmediate(() => {\n        this.listener.onError({\n          code: constants_1.Status.UNAVAILABLE,\n          details: `Failed to parse DNS address ${uri_parser_1.uriToString(this.target)}`,\n          metadata: new metadata_1.Metadata()\n        });\n      });\n    } else {\n      /* We clear out latestLookupResult here to ensure that it contains the\n       * latest result since the last time we started resolving. That way, the\n       * TXT resolution handler can use it, but only if it finishes second. We\n       * don't clear out any previous service config results because it's\n       * better to use a service config that's slightly out of date than to\n       * revert to an effectively blank one. */\n      this.latestLookupResult = null;\n      const hostname = this.dnsHostname;\n      /* We lookup both address families here and then split them up later\n       * because when looking up a single family, dns.lookup outputs an error\n       * if the name exists but there are no records for that family, and that\n       * error is indistinguishable from other kinds of errors */\n\n      this.pendingLookupPromise = dnsLookupPromise(hostname, {\n        all: true\n      });\n      this.pendingLookupPromise.then(addressList => {\n        this.pendingLookupPromise = null;\n        const ip4Addresses = addressList.filter(addr => addr.family === 4);\n        const ip6Addresses = addressList.filter(addr => addr.family === 6);\n        this.latestLookupResult = mergeArrays(ip6Addresses, ip4Addresses).map(addr => ({\n          host: addr.address,\n          port: +this.port\n        }));\n        const allAddressesString = '[' + this.latestLookupResult.map(addr => addr.host + ':' + addr.port).join(',') + ']';\n        trace('Resolved addresses for target ' + uri_parser_1.uriToString(this.target) + ': ' + allAddressesString);\n\n        if (this.latestLookupResult.length === 0) {\n          this.listener.onError(this.defaultResolutionError);\n          return;\n        }\n        /* If the TXT lookup has not yet finished, both of the last two\n         * arguments will be null, which is the equivalent of getting an\n         * empty TXT response. When the TXT lookup does finish, its handler\n         * can update the service config by using the same address list */\n\n\n        this.listener.onSuccessfulResolution(this.latestLookupResult, this.latestServiceConfig, this.latestServiceConfigError, null, {});\n      }, err => {\n        trace('Resolution error for target ' + uri_parser_1.uriToString(this.target) + ': ' + err.message);\n        this.pendingLookupPromise = null;\n        this.listener.onError(this.defaultResolutionError);\n      });\n      /* If there already is a still-pending TXT resolution, we can just use\n       * that result when it comes in */\n\n      if (this.pendingTxtPromise === null) {\n        /* We handle the TXT query promise differently than the others because\n         * the name resolution attempt as a whole is a success even if the TXT\n         * lookup fails */\n        this.pendingTxtPromise = resolveTxtPromise(hostname);\n        this.pendingTxtPromise.then(txtRecord => {\n          this.pendingTxtPromise = null;\n\n          try {\n            this.latestServiceConfig = service_config_1.extractAndSelectServiceConfig(txtRecord, this.percentage);\n          } catch (err) {\n            this.latestServiceConfigError = {\n              code: constants_1.Status.UNAVAILABLE,\n              details: 'Parsing service config failed',\n              metadata: new metadata_1.Metadata()\n            };\n          }\n\n          if (this.latestLookupResult !== null) {\n            /* We rely here on the assumption that calling this function with\n             * identical parameters will be essentialy idempotent, and calling\n             * it with the same address list and a different service config\n             * should result in a fast and seamless switchover. */\n            this.listener.onSuccessfulResolution(this.latestLookupResult, this.latestServiceConfig, this.latestServiceConfigError, null, {});\n          }\n        }, err => {\n          /* If TXT lookup fails we should do nothing, which means that we\n           * continue to use the result of the most recent successful lookup,\n           * or the default null config object if there has never been a\n           * successful lookup. We do not set the latestServiceConfigError\n           * here because that is specifically used for response validation\n           * errors. We still need to handle this error so that it does not\n           * bubble up as an unhandled promise rejection. */\n        });\n      }\n    }\n  }\n\n  updateResolution() {\n    trace('Resolution update requested for target ' + uri_parser_1.uriToString(this.target));\n\n    if (this.pendingLookupPromise === null) {\n      this.startResolution();\n    }\n  }\n\n  destroy() {\n    /* Do nothing. There is not a practical way to cancel in-flight DNS\n     * requests, and after this function is called we can expect that\n     * updateResolution will not be called again. */\n  }\n  /**\n   * Get the default authority for the given target. For IP targets, that is\n   * the IP address. For DNS targets, it is the hostname.\n   * @param target\n   */\n\n\n  static getDefaultAuthority(target) {\n    return target.path;\n  }\n\n}\n/**\n * Set up the DNS resolver class by registering it as the handler for the\n * \"dns:\" prefix and as the default resolver.\n */\n\n\nfunction setup() {\n  resolver_1.registerResolver('dns', DnsResolver);\n  resolver_1.registerDefaultScheme('dns');\n}\n\nexports.setup = setup;","map":{"version":3,"sources":["../../src/resolver-dns.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.setup = void 0;\nconst resolver_1 = require(\"./resolver\");\nconst dns = require(\"dns\");\nconst util = require(\"util\");\nconst service_config_1 = require(\"./service-config\");\nconst constants_1 = require(\"./constants\");\nconst metadata_1 = require(\"./metadata\");\nconst logging = require(\"./logging\");\nconst constants_2 = require(\"./constants\");\nconst uri_parser_1 = require(\"./uri-parser\");\nconst net_1 = require(\"net\");\nconst TRACER_NAME = 'dns_resolver';\nfunction trace(text) {\n    logging.trace(constants_2.LogVerbosity.DEBUG, TRACER_NAME, text);\n}\n/**\n * The default TCP port to connect to if not explicitly specified in the target.\n */\nconst DEFAULT_PORT = 443;\nconst resolveTxtPromise = util.promisify(dns.resolveTxt);\nconst dnsLookupPromise = util.promisify(dns.lookup);\n/**\n * Merge any number of arrays into a single alternating array\n * @param arrays\n */\nfunction mergeArrays(...arrays) {\n    const result = [];\n    for (let i = 0; i <\n        Math.max.apply(null, arrays.map((array) => array.length)); i++) {\n        for (const array of arrays) {\n            if (i < array.length) {\n                result.push(array[i]);\n            }\n        }\n    }\n    return result;\n}\n/**\n * Resolver implementation that handles DNS names and IP addresses.\n */\nclass DnsResolver {\n    constructor(target, listener, channelOptions) {\n        var _a, _b;\n        this.target = target;\n        this.listener = listener;\n        this.pendingLookupPromise = null;\n        this.pendingTxtPromise = null;\n        this.latestLookupResult = null;\n        this.latestServiceConfig = null;\n        this.latestServiceConfigError = null;\n        trace('Resolver constructed for target ' + uri_parser_1.uriToString(target));\n        const hostPort = uri_parser_1.splitHostPort(target.path);\n        if (hostPort === null) {\n            this.ipResult = null;\n            this.dnsHostname = null;\n            this.port = null;\n        }\n        else {\n            if (net_1.isIPv4(hostPort.host) || net_1.isIPv6(hostPort.host)) {\n                this.ipResult = [\n                    {\n                        host: hostPort.host,\n                        port: (_a = hostPort.port) !== null && _a !== void 0 ? _a : DEFAULT_PORT,\n                    },\n                ];\n                this.dnsHostname = null;\n                this.port = null;\n            }\n            else {\n                this.ipResult = null;\n                this.dnsHostname = hostPort.host;\n                this.port = (_b = hostPort.port) !== null && _b !== void 0 ? _b : DEFAULT_PORT;\n            }\n        }\n        this.percentage = Math.random() * 100;\n        this.defaultResolutionError = {\n            code: constants_1.Status.UNAVAILABLE,\n            details: `Name resolution failed for target ${uri_parser_1.uriToString(this.target)}`,\n            metadata: new metadata_1.Metadata(),\n        };\n    }\n    /**\n     * If the target is an IP address, just provide that address as a result.\n     * Otherwise, initiate A, AAAA, and TXT lookups\n     */\n    startResolution() {\n        if (this.ipResult !== null) {\n            trace('Returning IP address for target ' + uri_parser_1.uriToString(this.target));\n            setImmediate(() => {\n                this.listener.onSuccessfulResolution(this.ipResult, null, null, null, {});\n            });\n            return;\n        }\n        if (this.dnsHostname === null) {\n            setImmediate(() => {\n                this.listener.onError({\n                    code: constants_1.Status.UNAVAILABLE,\n                    details: `Failed to parse DNS address ${uri_parser_1.uriToString(this.target)}`,\n                    metadata: new metadata_1.Metadata(),\n                });\n            });\n        }\n        else {\n            /* We clear out latestLookupResult here to ensure that it contains the\n             * latest result since the last time we started resolving. That way, the\n             * TXT resolution handler can use it, but only if it finishes second. We\n             * don't clear out any previous service config results because it's\n             * better to use a service config that's slightly out of date than to\n             * revert to an effectively blank one. */\n            this.latestLookupResult = null;\n            const hostname = this.dnsHostname;\n            /* We lookup both address families here and then split them up later\n             * because when looking up a single family, dns.lookup outputs an error\n             * if the name exists but there are no records for that family, and that\n             * error is indistinguishable from other kinds of errors */\n            this.pendingLookupPromise = dnsLookupPromise(hostname, { all: true });\n            this.pendingLookupPromise.then((addressList) => {\n                this.pendingLookupPromise = null;\n                const ip4Addresses = addressList.filter((addr) => addr.family === 4);\n                const ip6Addresses = addressList.filter((addr) => addr.family === 6);\n                this.latestLookupResult = mergeArrays(ip6Addresses, ip4Addresses).map((addr) => ({ host: addr.address, port: +this.port }));\n                const allAddressesString = '[' +\n                    this.latestLookupResult\n                        .map((addr) => addr.host + ':' + addr.port)\n                        .join(',') +\n                    ']';\n                trace('Resolved addresses for target ' +\n                    uri_parser_1.uriToString(this.target) +\n                    ': ' +\n                    allAddressesString);\n                if (this.latestLookupResult.length === 0) {\n                    this.listener.onError(this.defaultResolutionError);\n                    return;\n                }\n                /* If the TXT lookup has not yet finished, both of the last two\n                 * arguments will be null, which is the equivalent of getting an\n                 * empty TXT response. When the TXT lookup does finish, its handler\n                 * can update the service config by using the same address list */\n                this.listener.onSuccessfulResolution(this.latestLookupResult, this.latestServiceConfig, this.latestServiceConfigError, null, {});\n            }, (err) => {\n                trace('Resolution error for target ' +\n                    uri_parser_1.uriToString(this.target) +\n                    ': ' +\n                    err.message);\n                this.pendingLookupPromise = null;\n                this.listener.onError(this.defaultResolutionError);\n            });\n            /* If there already is a still-pending TXT resolution, we can just use\n             * that result when it comes in */\n            if (this.pendingTxtPromise === null) {\n                /* We handle the TXT query promise differently than the others because\n                 * the name resolution attempt as a whole is a success even if the TXT\n                 * lookup fails */\n                this.pendingTxtPromise = resolveTxtPromise(hostname);\n                this.pendingTxtPromise.then((txtRecord) => {\n                    this.pendingTxtPromise = null;\n                    try {\n                        this.latestServiceConfig = service_config_1.extractAndSelectServiceConfig(txtRecord, this.percentage);\n                    }\n                    catch (err) {\n                        this.latestServiceConfigError = {\n                            code: constants_1.Status.UNAVAILABLE,\n                            details: 'Parsing service config failed',\n                            metadata: new metadata_1.Metadata(),\n                        };\n                    }\n                    if (this.latestLookupResult !== null) {\n                        /* We rely here on the assumption that calling this function with\n                         * identical parameters will be essentialy idempotent, and calling\n                         * it with the same address list and a different service config\n                         * should result in a fast and seamless switchover. */\n                        this.listener.onSuccessfulResolution(this.latestLookupResult, this.latestServiceConfig, this.latestServiceConfigError, null, {});\n                    }\n                }, (err) => {\n                    /* If TXT lookup fails we should do nothing, which means that we\n                     * continue to use the result of the most recent successful lookup,\n                     * or the default null config object if there has never been a\n                     * successful lookup. We do not set the latestServiceConfigError\n                     * here because that is specifically used for response validation\n                     * errors. We still need to handle this error so that it does not\n                     * bubble up as an unhandled promise rejection. */\n                });\n            }\n        }\n    }\n    updateResolution() {\n        trace('Resolution update requested for target ' + uri_parser_1.uriToString(this.target));\n        if (this.pendingLookupPromise === null) {\n            this.startResolution();\n        }\n    }\n    destroy() {\n        /* Do nothing. There is not a practical way to cancel in-flight DNS\n         * requests, and after this function is called we can expect that\n         * updateResolution will not be called again. */\n    }\n    /**\n     * Get the default authority for the given target. For IP targets, that is\n     * the IP address. For DNS targets, it is the hostname.\n     * @param target\n     */\n    static getDefaultAuthority(target) {\n        return target.path;\n    }\n}\n/**\n * Set up the DNS resolver class by registering it as the handler for the\n * \"dns:\" prefix and as the default resolver.\n */\nfunction setup() {\n    resolver_1.registerResolver('dns', DnsResolver);\n    resolver_1.registerDefaultScheme('dns');\n}\nexports.setup = setup;\n//# sourceMappingURL=resolver-dns.js.map"]},"metadata":{},"sourceType":"script"}