{"ast":null,"code":"\"use strict\";\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.registerAll = exports.mapUriDefaultScheme = exports.getDefaultAuthority = exports.createResolver = exports.registerDefaultScheme = exports.registerResolver = void 0;\n\nconst resolver_dns = require(\"./resolver-dns\");\n\nconst resolver_uds = require(\"./resolver-uds\");\n\nconst resolver_ip = require(\"./resolver-ip\");\n\nconst uri_parser_1 = require(\"./uri-parser\");\n\nconst registeredResolvers = {};\nlet defaultScheme = null;\n/**\n * Register a resolver class to handle target names prefixed with the `prefix`\n * string. This prefix should correspond to a URI scheme name listed in the\n * [gRPC Name Resolution document](https://github.com/grpc/grpc/blob/master/doc/naming.md)\n * @param prefix\n * @param resolverClass\n */\n\nfunction registerResolver(scheme, resolverClass) {\n  registeredResolvers[scheme] = resolverClass;\n}\n\nexports.registerResolver = registerResolver;\n/**\n * Register a default resolver to handle target names that do not start with\n * any registered prefix.\n * @param resolverClass\n */\n\nfunction registerDefaultScheme(scheme) {\n  defaultScheme = scheme;\n}\n\nexports.registerDefaultScheme = registerDefaultScheme;\n/**\n * Create a name resolver for the specified target, if possible. Throws an\n * error if no such name resolver can be created.\n * @param target\n * @param listener\n */\n\nfunction createResolver(target, listener, options) {\n  if (target.scheme !== undefined && target.scheme in registeredResolvers) {\n    return new registeredResolvers[target.scheme](target, listener, options);\n  } else {\n    throw new Error(`No resolver could be created for target ${uri_parser_1.uriToString(target)}`);\n  }\n}\n\nexports.createResolver = createResolver;\n/**\n * Get the default authority for the specified target, if possible. Throws an\n * error if no registered name resolver can parse that target string.\n * @param target\n */\n\nfunction getDefaultAuthority(target) {\n  if (target.scheme !== undefined && target.scheme in registeredResolvers) {\n    return registeredResolvers[target.scheme].getDefaultAuthority(target);\n  } else {\n    throw new Error(`Invalid target ${uri_parser_1.uriToString(target)}`);\n  }\n}\n\nexports.getDefaultAuthority = getDefaultAuthority;\n\nfunction mapUriDefaultScheme(target) {\n  if (target.scheme === undefined || !(target.scheme in registeredResolvers)) {\n    if (defaultScheme !== null) {\n      return {\n        scheme: defaultScheme,\n        authority: undefined,\n        path: uri_parser_1.uriToString(target)\n      };\n    } else {\n      return null;\n    }\n  }\n\n  return target;\n}\n\nexports.mapUriDefaultScheme = mapUriDefaultScheme;\n\nfunction registerAll() {\n  resolver_dns.setup();\n  resolver_uds.setup();\n  resolver_ip.setup();\n}\n\nexports.registerAll = registerAll;","map":{"version":3,"sources":["../../src/resolver.ts"],"names":[],"mappings":";AAAA;;;;;;;;;;;;;;;AAeG;;;;;;;AAGH,MAAA,YAAA,GAAA,OAAA,CAAA,gBAAA,CAAA;;AACA,MAAA,YAAA,GAAA,OAAA,CAAA,gBAAA,CAAA;;AACA,MAAA,WAAA,GAAA,OAAA,CAAA,eAAA,CAAA;;AAGA,MAAA,YAAA,GAAA,OAAA,CAAA,cAAA,CAAA;;AAkFA,MAAM,mBAAmB,GAA8C,EAAvE;AACA,IAAI,aAAa,GAAkB,IAAnC;AAEA;;;;;;AAMG;;AACH,SAAgB,gBAAhB,CACE,MADF,EAEE,aAFF,EAEoC;AAElC,EAAA,mBAAmB,CAAC,MAAD,CAAnB,GAA8B,aAA9B;AACD;;AALD,OAAA,CAAA,gBAAA,GAAA,gBAAA;AAOA;;;;AAIG;;AACH,SAAgB,qBAAhB,CAAsC,MAAtC,EAAoD;AAClD,EAAA,aAAa,GAAG,MAAhB;AACD;;AAFD,OAAA,CAAA,qBAAA,GAAA,qBAAA;AAIA;;;;;AAKG;;AACH,SAAgB,cAAhB,CACE,MADF,EAEE,QAFF,EAGE,OAHF,EAGyB;AAEvB,MAAI,MAAM,CAAC,MAAP,KAAkB,SAAlB,IAA+B,MAAM,CAAC,MAAP,IAAiB,mBAApD,EAAyE;AACvE,WAAO,IAAI,mBAAmB,CAAC,MAAM,CAAC,MAAR,CAAvB,CAAuC,MAAvC,EAA+C,QAA/C,EAAyD,OAAzD,CAAP;AACD,GAFD,MAEO;AACL,UAAM,IAAI,KAAJ,CACJ,2CAA2C,YAAA,CAAA,WAAA,CAAY,MAAZ,CAAmB,EAD1D,CAAN;AAGD;AACF;;AAZD,OAAA,CAAA,cAAA,GAAA,cAAA;AAcA;;;;AAIG;;AACH,SAAgB,mBAAhB,CAAoC,MAApC,EAAmD;AACjD,MAAI,MAAM,CAAC,MAAP,KAAkB,SAAlB,IAA+B,MAAM,CAAC,MAAP,IAAiB,mBAApD,EAAyE;AACvE,WAAO,mBAAmB,CAAC,MAAM,CAAC,MAAR,CAAnB,CAAmC,mBAAnC,CAAuD,MAAvD,CAAP;AACD,GAFD,MAEO;AACL,UAAM,IAAI,KAAJ,CAAU,kBAAkB,YAAA,CAAA,WAAA,CAAY,MAAZ,CAAmB,EAA/C,CAAN;AACD;AACF;;AAND,OAAA,CAAA,mBAAA,GAAA,mBAAA;;AAQA,SAAgB,mBAAhB,CAAoC,MAApC,EAAmD;AACjD,MAAI,MAAM,CAAC,MAAP,KAAkB,SAAlB,IAA+B,EAAE,MAAM,CAAC,MAAP,IAAiB,mBAAnB,CAAnC,EAA4E;AAC1E,QAAI,aAAa,KAAK,IAAtB,EAA4B;AAC1B,aAAO;AACL,QAAA,MAAM,EAAE,aADH;AAEL,QAAA,SAAS,EAAE,SAFN;AAGL,QAAA,IAAI,EAAE,YAAA,CAAA,WAAA,CAAY,MAAZ;AAHD,OAAP;AAKD,KAND,MAMO;AACL,aAAO,IAAP;AACD;AACF;;AACD,SAAO,MAAP;AACD;;AAbD,OAAA,CAAA,mBAAA,GAAA,mBAAA;;AAeA,SAAgB,WAAhB,GAA2B;AACzB,EAAA,YAAY,CAAC,KAAb;AACA,EAAA,YAAY,CAAC,KAAb;AACA,EAAA,WAAW,CAAC,KAAZ;AACD;;AAJD,OAAA,CAAA,WAAA,GAAA,WAAA","sourceRoot":"","sourcesContent":["\"use strict\";\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.registerAll = exports.mapUriDefaultScheme = exports.getDefaultAuthority = exports.createResolver = exports.registerDefaultScheme = exports.registerResolver = void 0;\nconst resolver_dns = require(\"./resolver-dns\");\nconst resolver_uds = require(\"./resolver-uds\");\nconst resolver_ip = require(\"./resolver-ip\");\nconst uri_parser_1 = require(\"./uri-parser\");\nconst registeredResolvers = {};\nlet defaultScheme = null;\n/**\n * Register a resolver class to handle target names prefixed with the `prefix`\n * string. This prefix should correspond to a URI scheme name listed in the\n * [gRPC Name Resolution document](https://github.com/grpc/grpc/blob/master/doc/naming.md)\n * @param prefix\n * @param resolverClass\n */\nfunction registerResolver(scheme, resolverClass) {\n    registeredResolvers[scheme] = resolverClass;\n}\nexports.registerResolver = registerResolver;\n/**\n * Register a default resolver to handle target names that do not start with\n * any registered prefix.\n * @param resolverClass\n */\nfunction registerDefaultScheme(scheme) {\n    defaultScheme = scheme;\n}\nexports.registerDefaultScheme = registerDefaultScheme;\n/**\n * Create a name resolver for the specified target, if possible. Throws an\n * error if no such name resolver can be created.\n * @param target\n * @param listener\n */\nfunction createResolver(target, listener, options) {\n    if (target.scheme !== undefined && target.scheme in registeredResolvers) {\n        return new registeredResolvers[target.scheme](target, listener, options);\n    }\n    else {\n        throw new Error(`No resolver could be created for target ${uri_parser_1.uriToString(target)}`);\n    }\n}\nexports.createResolver = createResolver;\n/**\n * Get the default authority for the specified target, if possible. Throws an\n * error if no registered name resolver can parse that target string.\n * @param target\n */\nfunction getDefaultAuthority(target) {\n    if (target.scheme !== undefined && target.scheme in registeredResolvers) {\n        return registeredResolvers[target.scheme].getDefaultAuthority(target);\n    }\n    else {\n        throw new Error(`Invalid target ${uri_parser_1.uriToString(target)}`);\n    }\n}\nexports.getDefaultAuthority = getDefaultAuthority;\nfunction mapUriDefaultScheme(target) {\n    if (target.scheme === undefined || !(target.scheme in registeredResolvers)) {\n        if (defaultScheme !== null) {\n            return {\n                scheme: defaultScheme,\n                authority: undefined,\n                path: uri_parser_1.uriToString(target),\n            };\n        }\n        else {\n            return null;\n        }\n    }\n    return target;\n}\nexports.mapUriDefaultScheme = mapUriDefaultScheme;\nfunction registerAll() {\n    resolver_dns.setup();\n    resolver_uds.setup();\n    resolver_ip.setup();\n}\nexports.registerAll = registerAll;\n//# sourceMappingURL=resolver.js.map"]},"metadata":{},"sourceType":"script"}